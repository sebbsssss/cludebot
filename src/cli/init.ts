import * as readline from 'readline';
import * as fs from 'fs';
import * as path from 'path';
import { printBanner, printStep, printSuccess, printWarn, printInfo, printDivider, printCodeBlock, c } from './banner';

interface InitConfig {
  supabaseUrl: string;
  supabaseKey: string;
  anthropicKey: string;
  embeddingProvider: string;
  embeddingKey: string;
  solanaRpc: string;
  walletKey: string;
}

function createPrompt(): readline.Interface {
  return readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });
}

function ask(rl: readline.Interface, question: string): Promise<string> {
  return new Promise((resolve) => {
    rl.question(`  ${c.white}?${c.reset} ${question}`, (answer) => {
      resolve(answer.trim());
    });
  });
}

function askChoice(rl: readline.Interface, question: string, choices: string[]): Promise<string> {
  const choiceStr = choices.map((ch, i) => `${c.cyan}${i + 1}${c.reset}) ${ch}`).join('  ');
  return new Promise((resolve) => {
    rl.question(`  ${c.white}?${c.reset} ${question} [${choiceStr}]: `, (answer) => {
      const idx = parseInt(answer.trim(), 10) - 1;
      if (idx >= 0 && idx < choices.length) {
        resolve(choices[idx]);
      } else if (choices.map(c => c.toLowerCase()).includes(answer.trim().toLowerCase())) {
        resolve(answer.trim().toLowerCase());
      } else {
        resolve(choices[0]);
      }
    });
  });
}

async function testSupabaseConnection(url: string, key: string): Promise<boolean> {
  try {
    const { createClient } = require('@supabase/supabase-js');
    const client = createClient(url, key);
    const { error } = await client.from('_health_check_nonexistent').select('*').limit(1);
    if (error && error.message.includes('does not exist')) return true;
    if (error && error.code === '42P01') return true;
    if (!error) return true;
    if (error.message.includes('fetch') || error.message.includes('ENOTFOUND') || error.message.includes('ECONNREFUSED')) {
      return false;
    }
    return true;
  } catch {
    return false;
  }
}

async function runSchema(url: string, key: string): Promise<{ tables: number; errors: string[] }> {
  const { createClient } = require('@supabase/supabase-js');
  const client = createClient(url, key);
  const errors: string[] = [];
  let tables = 0;

  const schemaPath = path.resolve(__dirname, '..', '..', 'supabase-schema.sql');
  let sql: string;
  try {
    sql = fs.readFileSync(schemaPath, 'utf-8');
  } catch {
    try {
      sql = fs.readFileSync(path.resolve(__dirname, '..', 'supabase-schema.sql'), 'utf-8');
    } catch {
      return { tables: 0, errors: ['Could not find supabase-schema.sql'] };
    }
  }

  const statements = sql
    .split(';')
    .map(s => s.trim())
    .filter(s => s.length > 0 && !s.startsWith('--'));

  for (const stmt of statements) {
    try {
      const { error } = await client.rpc('exec_sql', { sql: stmt + ';' }).single();
      if (error) {
        if (!error.message.includes('already exists')) {
          errors.push(error.message.slice(0, 80));
        }
      }
      if (stmt.toUpperCase().includes('CREATE TABLE')) tables++;
    } catch {
      // exec_sql might not exist
    }
  }

  return { tables, errors };
}

function generateEnvFile(config: InitConfig): string {
  let env = `# Generated by clude-bot init\n\n`;

  env += `# Supabase (required)\n`;
  env += `SUPABASE_URL=${config.supabaseUrl || 'https://your-project.supabase.co'}\n`;
  env += `SUPABASE_KEY=${config.supabaseKey || 'your-service-role-key'}\n\n`;

  env += `# Anthropic (optional — enables dream cycles + LLM importance scoring)\n`;
  env += `ANTHROPIC_API_KEY=${config.anthropicKey || ''}\n\n`;

  env += `# Solana (optional — on-chain memory commits)\n`;
  env += `SOLANA_RPC_URL=${config.solanaRpc || 'https://api.mainnet-beta.solana.com'}\n`;
  env += `BOT_WALLET_PRIVATE_KEY=${config.walletKey || ''}\n\n`;

  env += `# Embeddings (optional — enables vector similarity search)\n`;
  if (config.embeddingProvider) {
    env += `EMBEDDING_PROVIDER=${config.embeddingProvider}\n`;
    if (config.embeddingProvider === 'openai') {
      env += `OPENAI_API_KEY=${config.embeddingKey || ''}\n`;
    } else {
      env += `VOYAGE_API_KEY=${config.embeddingKey || ''}\n`;
    }
  } else {
    env += `# EMBEDDING_PROVIDER=voyage\n`;
    env += `# VOYAGE_API_KEY=\n`;
  }

  return env;
}

function generateCodeSnippet(config: InitConfig): string {
  let snippet = `const { Cortex } = require('clude-bot');\n\n`;
  snippet += `const brain = new Cortex({\n`;
  snippet += `  supabase: {\n`;
  snippet += `    url: process.env.SUPABASE_URL,\n`;
  snippet += `    serviceKey: process.env.SUPABASE_KEY,\n`;
  snippet += `  },\n`;

  if (config.anthropicKey) {
    snippet += `  anthropic: {\n`;
    snippet += `    apiKey: process.env.ANTHROPIC_API_KEY,\n`;
    snippet += `  },\n`;
  }

  if (config.walletKey || config.solanaRpc) {
    snippet += `  solana: {\n`;
    if (config.solanaRpc) {
      snippet += `    rpcUrl: process.env.SOLANA_RPC_URL,\n`;
    }
    if (config.walletKey) {
      snippet += `    botWalletPrivateKey: process.env.BOT_WALLET_PRIVATE_KEY,\n`;
    }
    snippet += `  },\n`;
  }

  if (config.embeddingProvider && config.embeddingKey) {
    const envVar = config.embeddingProvider === 'voyage' ? 'VOYAGE_API_KEY' : 'OPENAI_API_KEY';
    snippet += `  embedding: {\n`;
    snippet += `    provider: '${config.embeddingProvider}',\n`;
    snippet += `    apiKey: process.env.${envVar},\n`;
    snippet += `  },\n`;
  }

  snippet += `});\n\n`;
  snippet += `await brain.init();\n\n`;
  snippet += `await brain.store({\n`;
  snippet += `  type: 'episodic',\n`;
  snippet += `  content: 'User asked about pricing.',\n`;
  snippet += `  summary: 'Pricing question',\n`;
  snippet += `  source: 'my-agent',\n`;
  snippet += `});\n\n`;
  snippet += `const memories = await brain.recall({ query: 'pricing' });\n`;
  snippet += `console.log(brain.formatContext(memories));`;

  return snippet;
}

export async function runInit(): Promise<void> {
  printBanner();
  console.log(`  ${c.bold}Welcome to Clude Bot${c.reset} — let's give your agent a brain.\n`);
  console.log(`  ${c.gray}Press Enter to skip any step. You can fill in keys later in .env${c.reset}\n`);

  const rl = createPrompt();

  const config: InitConfig = {
    supabaseUrl: '',
    supabaseKey: '',
    anthropicKey: '',
    embeddingProvider: '',
    embeddingKey: '',
    solanaRpc: '',
    walletKey: '',
  };

  // ─── Step 1: Supabase ───────────────────────────────────
  printStep(1, 4, 'Supabase');
  printInfo('Your memories live in Supabase (PostgreSQL + pgvector).');
  printInfo('Free project at https://supabase.com — or skip to configure later.\n');

  config.supabaseUrl = await ask(rl, 'Supabase URL (Enter to skip): ');
  let connected = false;

  if (config.supabaseUrl) {
    config.supabaseKey = await ask(rl, 'Service Role Key: ');

    if (config.supabaseUrl && config.supabaseKey) {
      console.log('');
      process.stdout.write(`  ${c.gray}Testing connection...${c.reset}`);
      connected = await testSupabaseConnection(config.supabaseUrl, config.supabaseKey);
      process.stdout.clearLine(0);
      process.stdout.cursorTo(0);

      if (connected) {
        printSuccess('Connected to Supabase');

        // Offer schema setup
        const schemaChoice = await ask(rl, 'Run database schema setup? (Y/n): ');
        if (schemaChoice.toLowerCase() !== 'n') {
          process.stdout.write(`  ${c.gray}Running schema...${c.reset}`);
          const result = await runSchema(config.supabaseUrl, config.supabaseKey);
          process.stdout.clearLine(0);
          process.stdout.cursorTo(0);

          if (result.errors.length === 0 && result.tables > 0) {
            printSuccess(`Schema applied (${result.tables} tables)`);
          } else {
            printWarn('Auto-setup needs an exec_sql RPC function.');
            printInfo('Paste supabase-schema.sql into your SQL Editor instead.');
          }
        }
      } else {
        printWarn('Could not connect — check URL and key in .env later');
      }
    }
  } else {
    console.log('');
    printInfo('Skipped — add SUPABASE_URL and SUPABASE_KEY to .env later');
    printInfo('Schema: paste node_modules/clude-bot/supabase-schema.sql into SQL Editor');
  }

  // ─── Step 2: Anthropic ──────────────────────────────────
  printStep(2, 4, 'Anthropic');
  printInfo('Enables dream cycles and LLM importance scoring.');
  printInfo('Not needed for basic store/recall.\n');

  config.anthropicKey = await ask(rl, 'Anthropic API Key (Enter to skip): ');
  console.log('');

  if (config.anthropicKey) {
    printSuccess('Anthropic configured');
  } else {
    printInfo('Skipped — add ANTHROPIC_API_KEY to .env later for dream cycles');
  }

  // ─── Step 3: Embeddings ─────────────────────────────────
  printStep(3, 4, 'Solana');
  printInfo('Commit memory hashes on-chain for verifiable agent history.');
  printInfo('Requires an RPC endpoint and a wallet with SOL for fees.\n');

  config.solanaRpc = await ask(rl, 'Solana RPC URL (Enter for mainnet default): ');
  if (!config.solanaRpc) {
    config.solanaRpc = '';
  }

  config.walletKey = await ask(rl, 'Wallet private key — base58 (Enter to skip): ');
  console.log('');

  if (config.walletKey) {
    printSuccess('Solana wallet configured — on-chain memory commits enabled');
  } else if (config.solanaRpc) {
    printInfo('No wallet — read-only Solana access');
  } else {
    printInfo('Skipped — add SOLANA_RPC_URL and BOT_WALLET_PRIVATE_KEY to .env later');
  }

  // ─── Step 4: Embeddings ─────────────────────────────────
  printStep(4, 4, 'Embeddings');
  printInfo('Enables vector similarity search. Without it, recall uses');
  printInfo('keyword + tag matching (still works fine).\n');

  const embChoice = await askChoice(rl, 'Provider', ['skip', 'voyage', 'openai']);

  if (embChoice !== 'skip') {
    config.embeddingProvider = embChoice;
    config.embeddingKey = await ask(rl, `${embChoice === 'voyage' ? 'Voyage AI' : 'OpenAI'} API Key: `);
    console.log('');

    if (config.embeddingKey) {
      printSuccess(`${embChoice === 'voyage' ? 'Voyage AI' : 'OpenAI'} embeddings configured`);
    } else {
      printInfo('No key — add it to .env later');
      config.embeddingProvider = '';
    }
  } else {
    console.log('');
    printInfo('Skipped — add EMBEDDING_PROVIDER + key to .env later');
  }

  // ─── Generate output ───────────────────────────────────
  printDivider();
  console.log(`\n  ${c.bold}${c.green}Done${c.reset}\n`);

  // Write .env file
  const envContent = generateEnvFile(config);
  const envPath = path.resolve(process.cwd(), '.env');
  const envExists = fs.existsSync(envPath);

  if (envExists) {
    const overwrite = await ask(rl, '.env exists. Overwrite? (y/N): ');
    if (overwrite.toLowerCase() === 'y') {
      fs.writeFileSync(envPath, envContent);
      printSuccess('Overwrote .env');
    } else {
      const altPath = path.resolve(process.cwd(), '.env.clude');
      fs.writeFileSync(altPath, envContent);
      printSuccess(`Saved to .env.clude`);
    }
  } else {
    fs.writeFileSync(envPath, envContent);
    printSuccess('Generated .env');
  }

  // Code snippet
  console.log(`\n  ${c.bold}Quick start:${c.reset}`);
  printCodeBlock(generateCodeSnippet(config));

  // What's enabled
  const hasSupabase = !!(config.supabaseUrl && config.supabaseKey);
  const hasAnthropic = !!config.anthropicKey;
  const hasSolana = !!config.walletKey;
  const hasEmbeddings = !!(config.embeddingProvider && config.embeddingKey);

  console.log(`  ${c.bold}Status:${c.reset}\n`);
  if (hasSupabase) {
    printSuccess('Store & recall memories');
    printSuccess('Memory decay + association graph');
  } else {
    printWarn('Supabase not configured yet — fill in .env');
  }
  if (hasAnthropic) {
    printSuccess('Dream cycles + LLM importance scoring');
  }
  if (hasSolana) {
    printSuccess('On-chain memory commits (Solana)');
  }
  if (hasEmbeddings) {
    printSuccess('Vector similarity search');
  }

  console.log(`\n  ${c.dim}Docs:    https://github.com/sebbsssss/cludebot${c.reset}`);
  console.log(`  ${c.dim}Website: https://clude.io${c.reset}`);
  printDivider();
  console.log('');

  rl.close();
}
