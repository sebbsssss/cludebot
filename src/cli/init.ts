import * as readline from 'readline';
import * as fs from 'fs';
import * as path from 'path';
import { printBanner, printStep, printSuccess, printWarn, printError, printInfo, printDivider, printCodeBlock, c } from './banner';

interface InitConfig {
  supabaseUrl: string;
  supabaseKey: string;
  anthropicKey: string;
  embeddingProvider: string;
  embeddingKey: string;
}

function createPrompt(): readline.Interface {
  return readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });
}

function ask(rl: readline.Interface, question: string, mask = false): Promise<string> {
  return new Promise((resolve) => {
    if (mask) {
      // For secret inputs, show dots
      const stdout = process.stdout;
      rl.question(`  ${c.white}?${c.reset} ${question}`, (answer) => {
        resolve(answer.trim());
      });
      // Mask input as it's typed
      const onData = (char: string | Buffer) => {
        const ch = char.toString();
        if (ch === '\n' || ch === '\r' || ch === '\u0004') return;
        if (ch === '\u007F' || ch === '\b') {
          // backspace
          stdout.clearLine(0);
          stdout.cursorTo(0);
          stdout.write(`  ${c.white}?${c.reset} ${question}`);
          return;
        }
        stdout.clearLine(0);
        stdout.cursorTo(0);
        stdout.write(`  ${c.white}?${c.reset} ${question}${'•'.repeat(rl.line.length)}`);
      };
      process.stdin.on('data', onData);
      rl.once('close', () => process.stdin.removeListener('data', onData));
    } else {
      rl.question(`  ${c.white}?${c.reset} ${question}`, (answer) => {
        resolve(answer.trim());
      });
    }
  });
}

function askChoice(rl: readline.Interface, question: string, choices: string[]): Promise<string> {
  const choiceStr = choices.map((ch, i) => `${c.cyan}${i + 1}${c.reset}) ${ch}`).join('  ');
  return new Promise((resolve) => {
    rl.question(`  ${c.white}?${c.reset} ${question} [${choiceStr}]: `, (answer) => {
      const idx = parseInt(answer.trim(), 10) - 1;
      if (idx >= 0 && idx < choices.length) {
        resolve(choices[idx]);
      } else if (choices.map(c => c.toLowerCase()).includes(answer.trim().toLowerCase())) {
        resolve(answer.trim().toLowerCase());
      } else {
        resolve(choices[0]); // default to first
      }
    });
  });
}

async function testSupabaseConnection(url: string, key: string): Promise<boolean> {
  try {
    const { createClient } = require('@supabase/supabase-js');
    const client = createClient(url, key);
    // Simple health check — try to query a non-existent table, expect a proper error (not a connection failure)
    const { error } = await client.from('_health_check_nonexistent').select('*').limit(1);
    // If we get any response (even an error about the table not existing), the connection works
    if (error && error.message.includes('does not exist')) return true;
    if (error && error.code === '42P01') return true; // relation does not exist
    if (!error) return true;
    // Connection-level errors
    if (error.message.includes('fetch') || error.message.includes('ENOTFOUND') || error.message.includes('ECONNREFUSED')) {
      return false;
    }
    return true; // any other error means connection is working
  } catch {
    return false;
  }
}

async function runSchema(url: string, key: string): Promise<{ tables: number; errors: string[] }> {
  const { createClient } = require('@supabase/supabase-js');
  const client = createClient(url, key);
  const errors: string[] = [];
  let tables = 0;

  // Read the schema SQL
  const schemaPath = path.resolve(__dirname, '..', '..', 'supabase-schema.sql');
  let sql: string;
  try {
    sql = fs.readFileSync(schemaPath, 'utf-8');
  } catch {
    // Try npm package location
    try {
      sql = fs.readFileSync(path.resolve(__dirname, '..', 'supabase-schema.sql'), 'utf-8');
    } catch {
      return { tables: 0, errors: ['Could not find supabase-schema.sql'] };
    }
  }

  // Split into individual statements
  const statements = sql
    .split(';')
    .map(s => s.trim())
    .filter(s => s.length > 0 && !s.startsWith('--'));

  for (const stmt of statements) {
    try {
      const { error } = await client.rpc('exec_sql', { sql: stmt + ';' }).single();
      if (error) {
        // Ignore "already exists" errors — that's fine
        if (!error.message.includes('already exists')) {
          errors.push(error.message.slice(0, 80));
        }
      }
      if (stmt.toUpperCase().includes('CREATE TABLE')) tables++;
    } catch {
      // exec_sql might not exist — that's expected
    }
  }

  return { tables, errors };
}

function generateEnvFile(config: InitConfig): string {
  let env = `# Generated by clude-bot init\n\n`;
  env += `# Supabase (required)\n`;
  env += `SUPABASE_URL=${config.supabaseUrl}\n`;
  env += `SUPABASE_KEY=${config.supabaseKey}\n\n`;

  if (config.anthropicKey) {
    env += `# Anthropic (enables dream cycles + LLM importance scoring)\n`;
    env += `ANTHROPIC_API_KEY=${config.anthropicKey}\n\n`;
  }

  if (config.embeddingProvider && config.embeddingKey) {
    env += `# Embeddings (enables vector similarity search)\n`;
    env += `EMBEDDING_PROVIDER=${config.embeddingProvider}\n`;
    if (config.embeddingProvider === 'voyage') {
      env += `VOYAGE_API_KEY=${config.embeddingKey}\n`;
    } else {
      env += `OPENAI_API_KEY=${config.embeddingKey}\n`;
    }
    env += `\n`;
  }

  return env;
}

function generateCodeSnippet(config: InitConfig): string {
  let snippet = `const { Cortex } = require('clude-bot');\n\n`;
  snippet += `const brain = new Cortex({\n`;
  snippet += `  supabase: {\n`;
  snippet += `    url: process.env.SUPABASE_URL,\n`;
  snippet += `    serviceKey: process.env.SUPABASE_KEY,\n`;
  snippet += `  },\n`;

  if (config.anthropicKey) {
    snippet += `  anthropic: {\n`;
    snippet += `    apiKey: process.env.ANTHROPIC_API_KEY,\n`;
    snippet += `  },\n`;
  }

  if (config.embeddingProvider && config.embeddingKey) {
    const envVar = config.embeddingProvider === 'voyage' ? 'VOYAGE_API_KEY' : 'OPENAI_API_KEY';
    snippet += `  embedding: {\n`;
    snippet += `    provider: '${config.embeddingProvider}',\n`;
    snippet += `    apiKey: process.env.${envVar},\n`;
    snippet += `  },\n`;
  }

  snippet += `});\n\n`;
  snippet += `await brain.init();\n`;
  snippet += `\n`;
  snippet += `// Store a memory\n`;
  snippet += `await brain.store({\n`;
  snippet += `  type: 'episodic',\n`;
  snippet += `  content: 'User asked about pricing.',\n`;
  snippet += `  summary: 'Pricing question',\n`;
  snippet += `  source: 'my-agent',\n`;
  snippet += `});\n`;
  snippet += `\n`;
  snippet += `// Recall relevant memories\n`;
  snippet += `const memories = await brain.recall({ query: 'pricing' });\n`;
  snippet += `console.log(brain.formatContext(memories));`;

  return snippet;
}

export async function runInit(): Promise<void> {
  printBanner();
  console.log(`  ${c.bold}Welcome to Clude Bot${c.reset} — let's give your agent a brain.`);
  console.log(`  This takes about 2 minutes.\n`);

  const rl = createPrompt();

  const config: InitConfig = {
    supabaseUrl: '',
    supabaseKey: '',
    anthropicKey: '',
    embeddingProvider: '',
    embeddingKey: '',
  };

  // ─── Step 1: Supabase ───────────────────────────────────
  printStep(1, 4, 'Supabase');
  printInfo('Your memories live in Supabase (PostgreSQL + pgvector).');
  printInfo('Create a free project at https://supabase.com if you haven\'t.\n');

  config.supabaseUrl = await ask(rl, 'Supabase URL: ');
  if (!config.supabaseUrl) {
    printError('Supabase URL is required.');
    rl.close();
    process.exit(1);
  }

  config.supabaseKey = await ask(rl, 'Service Role Key: ');
  if (!config.supabaseKey) {
    printError('Service Role Key is required.');
    rl.close();
    process.exit(1);
  }

  // Test connection
  console.log('');
  process.stdout.write(`  ${c.gray}Testing connection...${c.reset}`);
  const connected = await testSupabaseConnection(config.supabaseUrl, config.supabaseKey);
  process.stdout.clearLine(0);
  process.stdout.cursorTo(0);

  if (connected) {
    printSuccess('Connected to Supabase');
  } else {
    printError('Could not connect to Supabase. Check your URL and key.');
    printInfo('You can still generate the config and fix it later.\n');
  }

  // ─── Step 2: Schema ────────────────────────────────────
  printStep(2, 4, 'Database Schema');
  printInfo('The memory system needs tables, indexes, and pgvector functions.');
  printInfo('You can run the schema automatically or paste it manually.\n');

  const schemaChoice = await ask(rl, 'Try automatic schema setup? (Y/n): ');
  const runSchemaAuto = schemaChoice.toLowerCase() !== 'n';

  if (runSchemaAuto && connected) {
    console.log('');
    process.stdout.write(`  ${c.gray}Running schema...${c.reset}`);
    const result = await runSchema(config.supabaseUrl, config.supabaseKey);
    process.stdout.clearLine(0);
    process.stdout.cursorTo(0);

    if (result.errors.length === 0 && result.tables > 0) {
      printSuccess(`Schema applied (${result.tables} tables created)`);
    } else if (result.errors.length > 0) {
      printWarn('Some statements failed (this is normal if tables already exist)');
      printInfo('For best results, paste supabase-schema.sql into your SQL Editor.');
      printInfo('Find it at: node_modules/clude-bot/supabase-schema.sql');
    } else {
      printWarn('Auto-setup requires an exec_sql RPC function in Supabase.');
      printInfo('Paste supabase-schema.sql into your Supabase SQL Editor instead.');
      printInfo('Find it at: node_modules/clude-bot/supabase-schema.sql');
    }
  } else {
    printInfo('Manual setup: paste supabase-schema.sql into your Supabase SQL Editor.');
    printInfo('Find it at: node_modules/clude-bot/supabase-schema.sql');
  }

  // ─── Step 3: Anthropic ──────────────────────────────────
  printStep(3, 4, 'Anthropic');
  printInfo('Required for dream cycles (memory consolidation) and');
  printInfo('LLM-based importance scoring. Optional for basic store/recall.\n');

  config.anthropicKey = await ask(rl, 'Anthropic API Key (Enter to skip): ');
  console.log('');

  if (config.anthropicKey) {
    printSuccess('Anthropic configured — dream cycles enabled');
  } else {
    printWarn('Skipped — importance scoring will use rule-based fallback');
    printInfo('dream() will throw until you add an Anthropic key.');
  }

  // ─── Step 4: Embeddings ─────────────────────────────────
  printStep(4, 4, 'Embeddings');
  printInfo('Enables vector similarity search for memory recall.');
  printInfo('Without it, recall uses keyword + tag matching (still works).\n');

  const embChoice = await askChoice(rl, 'Embedding provider', ['voyage', 'openai', 'skip']);

  if (embChoice !== 'skip') {
    config.embeddingProvider = embChoice;
    config.embeddingKey = await ask(rl, `${embChoice === 'voyage' ? 'Voyage AI' : 'OpenAI'} API Key: `);
    console.log('');

    if (config.embeddingKey) {
      printSuccess(`${embChoice === 'voyage' ? 'Voyage AI' : 'OpenAI'} embeddings configured`);
    } else {
      printWarn('No key provided — embeddings disabled');
      config.embeddingProvider = '';
    }
  } else {
    console.log('');
    printWarn('Skipped — recall will use keyword + tag scoring only');
  }

  // ─── Generate output ───────────────────────────────────
  printDivider();
  console.log(`\n  ${c.bold}${c.green}Setup Complete${c.reset}\n`);

  // Write .env file
  const envContent = generateEnvFile(config);
  const envPath = path.resolve(process.cwd(), '.env');
  const envExists = fs.existsSync(envPath);

  if (envExists) {
    const overwrite = await ask(rl, '.env already exists. Overwrite? (y/N): ');
    if (overwrite.toLowerCase() === 'y') {
      fs.writeFileSync(envPath, envContent);
      printSuccess('Overwrote .env');
    } else {
      const altPath = path.resolve(process.cwd(), '.env.clude');
      fs.writeFileSync(altPath, envContent);
      printSuccess(`Saved to .env.clude (merge manually into .env)`);
    }
  } else {
    fs.writeFileSync(envPath, envContent);
    printSuccess('Generated .env');
  }

  // Show the code snippet
  console.log(`\n  ${c.bold}Quick start:${c.reset}`);
  printCodeBlock(generateCodeSnippet(config));

  // Feature summary
  console.log(`  ${c.bold}What's enabled:${c.reset}\n`);
  printSuccess('Store & recall memories');
  printSuccess('Memory decay (type-specific)');
  printSuccess('Association graph (Hebbian learning)');
  if (config.anthropicKey) {
    printSuccess('Dream cycles (consolidation + reflection + emergence)');
    printSuccess('LLM importance scoring');
  }
  if (config.embeddingProvider) {
    printSuccess('Vector similarity search (pgvector)');
  }
  if (!config.anthropicKey) {
    printInfo(`Add ANTHROPIC_API_KEY to .env later for dream cycles`);
  }
  if (!config.embeddingProvider) {
    printInfo(`Add EMBEDDING_PROVIDER + key to .env later for vector search`);
  }

  console.log(`\n  ${c.dim}Docs:    https://github.com/sebbsssss/cludebot${c.reset}`);
  console.log(`  ${c.dim}Website: https://clude.io${c.reset}`);
  printDivider();
  console.log('');

  rl.close();
}
