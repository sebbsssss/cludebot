<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CLUDE - The Cortex</title>
  <meta name="description" content="Neural map of an AI's memory. Each node a thought. Each edge a connection. Watch it think.">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;700&family=IBM+Plex+Mono:ital,wght@0,300;0,400;0,500;1,300;1,400&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #030308;
      --text: #999;
      --text-dim: #555;
      --text-faint: #2a2a2a;
      --accent: #e8622c;
      --episodic: #e8622c;
      --semantic: #4a8aff;
      --procedural: #4a8a5a;
      --selfmodel: #b04ae0;
      --mono: 'JetBrains Mono', 'IBM Plex Mono', 'Courier New', monospace;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: var(--mono);
      background: var(--bg);
      color: var(--text);
      font-size: 12px;
      -webkit-font-smoothing: antialiased;
      cursor: crosshair;
    }

    canvas {
      display: block;
      position: fixed;
      top: 0;
      left: 0;
    }

    /* ---- HUD OVERLAY ---- */
    .hud {
      position: fixed;
      z-index: 10;
      pointer-events: none;
    }

    .hud-top-left {
      top: 24px;
      left: 28px;
    }

    .hud-title {
      font-size: 11px;
      font-weight: 500;
      letter-spacing: 4px;
      text-transform: uppercase;
      color: #444;
      margin-bottom: 4px;
    }

    .hud-subtitle {
      font-size: 10px;
      color: #2a2a2a;
      letter-spacing: 2px;
    }

    .hud-stats {
      margin-top: 20px;
      font-size: 10px;
      line-height: 1.9;
      color: #333;
    }

    .hud-stats .val {
      color: #666;
      font-weight: 500;
    }

    .hud-stats .label {
      color: #2a2a2a;
      margin-left: 6px;
    }

    /* ---- TYPE LEGEND ---- */
    .hud-top-right {
      top: 24px;
      right: 28px;
    }

    .legend {
      text-align: right;
    }

    .legend-item {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 8px;
      margin-bottom: 6px;
      font-size: 10px;
      letter-spacing: 1px;
      color: #333;
      cursor: pointer;
      pointer-events: auto;
      transition: color 0.3s;
      user-select: none;
    }

    .legend-item:hover {
      color: #666;
    }

    .legend-item.disabled {
      opacity: 0.25;
    }

    .legend-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    /* ---- BOTTOM NAV ---- */
    .hud-bottom-left {
      bottom: 24px;
      left: 28px;
    }

    .hud-nav {
      font-size: 10px;
      letter-spacing: 1px;
      pointer-events: auto;
    }

    .hud-nav a {
      color: #333;
      text-decoration: none;
      transition: color 0.3s;
    }

    .hud-nav a:hover {
      color: var(--accent);
    }

    .hud-nav span {
      color: #1a1a1a;
      margin: 0 6px;
    }

    /* ---- CONTROLS ---- */
    .hud-bottom-right {
      bottom: 24px;
      right: 28px;
    }

    .controls {
      display: flex;
      gap: 4px;
      pointer-events: auto;
    }

    .ctrl-btn {
      width: 28px;
      height: 28px;
      border: 1px solid #1a1a1a;
      background: rgba(3, 3, 8, 0.8);
      color: #444;
      font-family: var(--mono);
      font-size: 14px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
    }

    .ctrl-btn:hover {
      border-color: #333;
      color: #888;
    }

    /* ---- DETAIL PANEL ---- */
    .detail-panel {
      position: fixed;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 20;
      background: rgba(6, 6, 12, 0.92);
      border: 1px solid #1a1a1a;
      padding: 16px 22px;
      max-width: 520px;
      width: 90%;
      backdrop-filter: blur(20px);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.25s;
    }

    .detail-panel.visible {
      opacity: 1;
      pointer-events: auto;
    }

    .detail-type {
      font-size: 9px;
      letter-spacing: 3px;
      text-transform: uppercase;
      margin-bottom: 6px;
    }

    .detail-summary {
      font-size: 12px;
      line-height: 1.7;
      color: #888;
      margin-bottom: 10px;
    }

    .detail-meta {
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
      font-size: 9px;
      color: #333;
      letter-spacing: 0.5px;
    }

    .detail-meta .val {
      color: #555;
    }

    .detail-tags {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      margin-top: 8px;
    }

    .detail-tag {
      font-size: 9px;
      color: #444;
      border: 1px solid #1a1a1a;
      padding: 1px 6px;
      letter-spacing: 0.5px;
    }

    .detail-evidence {
      margin-top: 8px;
      font-size: 9px;
      color: #2a2a2a;
    }

    .detail-evidence span {
      color: var(--accent);
    }

    /* ---- LOADING STATE ---- */
    .loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 30;
      text-align: center;
      transition: opacity 0.8s;
    }

    .loading.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .loading-text {
      font-size: 10px;
      letter-spacing: 4px;
      color: #2a2a2a;
      animation: pulse 2s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 0.3; }
      50% { opacity: 1; }
    }

    /* ---- SCANLINES ---- */
    body::after {
      content: '';
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: repeating-linear-gradient(
        0deg,
        transparent,
        transparent 3px,
        rgba(0, 0, 0, 0.04) 3px,
        rgba(0, 0, 0, 0.04) 6px
      );
      pointer-events: none;
      z-index: 9998;
    }
  </style>
</head>
<body>

  <div class="loading" id="loading">
    <div class="loading-text">MAPPING CORTEX</div>
  </div>

  <canvas id="brain"></canvas>

  <!-- HUD: top-left stats -->
  <div class="hud hud-top-left">
    <div class="hud-title">THE CORTEX</div>
    <div class="hud-subtitle">NEURAL MEMORY MAP</div>
    <div class="hud-stats" id="hudStats">
      <div><span class="val" id="statNodes">--</span><span class="label">nodes</span></div>
      <div><span class="val" id="statEdges">--</span><span class="label">edges</span></div>
      <div><span class="val" id="statAvgDecay">--</span><span class="label">avg decay</span></div>
      <div><span class="val" id="statAvgImp">--</span><span class="label">avg importance</span></div>
    </div>
  </div>

  <!-- HUD: top-right legend -->
  <div class="hud hud-top-right">
    <div class="legend" id="legend">
      <div class="legend-item" data-type="episodic" onclick="toggleType('episodic')">
        EPISODIC <div class="legend-dot" style="background: var(--episodic)"></div>
      </div>
      <div class="legend-item" data-type="semantic" onclick="toggleType('semantic')">
        SEMANTIC <div class="legend-dot" style="background: var(--semantic)"></div>
      </div>
      <div class="legend-item" data-type="procedural" onclick="toggleType('procedural')">
        PROCEDURAL <div class="legend-dot" style="background: var(--procedural)"></div>
      </div>
      <div class="legend-item" data-type="self_model" onclick="toggleType('self_model')">
        SELF-MODEL <div class="legend-dot" style="background: var(--selfmodel)"></div>
      </div>
    </div>
  </div>

  <!-- HUD: bottom-left nav -->
  <div class="hud hud-bottom-left">
    <div class="hud-nav">
      <a href="/">HOME</a>
      <span>/</span>
      <a href="/manifesto.html">MANIFESTO</a>
      <span>/</span>
      <a href="https://x.com/Cludebot" target="_blank">X</a>
    </div>
  </div>

  <!-- HUD: bottom-right controls -->
  <div class="hud hud-bottom-right">
    <div class="controls">
      <button class="ctrl-btn" onclick="zoomIn()" title="Zoom in">+</button>
      <button class="ctrl-btn" onclick="zoomOut()" title="Zoom out">&minus;</button>
      <button class="ctrl-btn" onclick="resetView()" title="Reset view">&cir;</button>
    </div>
  </div>

  <!-- Detail panel -->
  <div class="detail-panel" id="detailPanel">
    <div class="detail-type" id="detailType"></div>
    <div class="detail-summary" id="detailSummary"></div>
    <div class="detail-meta" id="detailMeta"></div>
    <div class="detail-tags" id="detailTags"></div>
    <div class="detail-evidence" id="detailEvidence"></div>
  </div>

<script>
(function() {
  'use strict';

  // ---- CONFIG ----
  var TYPE_COLORS = {
    episodic:   { r: 232, g: 98,  b: 44  },
    semantic:   { r: 74,  g: 138, b: 255 },
    procedural: { r: 74,  g: 138, b: 90  },
    self_model: { r: 176, g: 74,  b: 224 }
  };

  var PHYSICS = {
    repulsion: 800,
    attraction: 0.004,
    tagAttraction: 0.0008,
    centering: 0.01,
    damping: 0.92,
    minDistance: 40
  };

  // ---- STATE ----
  var canvas = document.getElementById('brain');
  var ctx = canvas.getContext('2d');
  var nodes = [];
  var edges = [];
  var tagEdges = [];
  var nodeMap = {};
  var hiddenTypes = {};
  var camera = { x: 0, y: 0, zoom: 1 };
  var targetCamera = { x: 0, y: 0, zoom: 1 };
  var mouse = { x: 0, y: 0, worldX: 0, worldY: 0 };
  var hoveredNode = null;
  var selectedNode = null;
  var dragging = false;
  var dragStart = { x: 0, y: 0, camX: 0, camY: 0 };
  var time = 0;
  var dpr = window.devicePixelRatio || 1;

  // ---- CANVAS SETUP ----
  function resize() {
    canvas.width = window.innerWidth * dpr;
    canvas.height = window.innerHeight * dpr;
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener('resize', resize);
  resize();

  // ---- DATA FETCH ----
  function fetchBrain() {
    fetch('/api/brain?limit=200')
      .then(function(r) { return r.json(); })
      .then(function(data) {
        if (!data.nodes || data.nodes.length === 0) {
          document.getElementById('loading').querySelector('.loading-text').textContent = 'NO MEMORIES FOUND';
          return;
        }
        buildGraph(data.nodes);
        document.getElementById('loading').classList.add('hidden');
      })
      .catch(function() {
        document.getElementById('loading').querySelector('.loading-text').textContent = 'CORTEX OFFLINE';
      });
  }

  // ---- GRAPH CONSTRUCTION ----
  function buildGraph(rawNodes) {
    nodes = [];
    edges = [];
    tagEdges = [];
    nodeMap = {};

    // Create nodes with random initial positions
    var spread = Math.sqrt(rawNodes.length) * 60;
    for (var i = 0; i < rawNodes.length; i++) {
      var raw = rawNodes[i];
      var angle = Math.random() * Math.PI * 2;
      var radius = Math.random() * spread;
      var node = {
        id: raw.id,
        type: raw.type,
        summary: raw.summary,
        tags: raw.tags,
        importance: raw.importance || 0.5,
        decay: raw.decay || 1,
        valence: raw.valence || 0,
        accessCount: raw.accessCount || 0,
        source: raw.source || '',
        evidenceIds: raw.evidenceIds || [],
        createdAt: raw.createdAt,
        lastAccessed: raw.lastAccessed,
        x: Math.cos(angle) * radius,
        y: Math.sin(angle) * radius,
        vx: 0,
        vy: 0,
        baseRadius: 3 + raw.importance * 10,
        pulsePhase: Math.random() * Math.PI * 2
      };
      nodes.push(node);
      nodeMap[node.id] = node;
    }

    // Build evidence edges
    for (var i = 0; i < nodes.length; i++) {
      var n = nodes[i];
      for (var j = 0; j < n.evidenceIds.length; j++) {
        var targetId = n.evidenceIds[j];
        if (nodeMap[targetId]) {
          edges.push({ source: n, target: nodeMap[targetId], type: 'evidence' });
        }
      }
    }

    // Build tag-based proximity edges (shared tags = weak attraction)
    var tagIndex = {};
    for (var i = 0; i < nodes.length; i++) {
      var n = nodes[i];
      for (var t = 0; t < n.tags.length; t++) {
        var tag = n.tags[t];
        if (!tagIndex[tag]) tagIndex[tag] = [];
        tagIndex[tag].push(n);
      }
    }
    var tagEdgeSet = {};
    var tagKeys = Object.keys(tagIndex);
    for (var k = 0; k < tagKeys.length; k++) {
      var group = tagIndex[tagKeys[k]];
      if (group.length < 2 || group.length > 30) continue; // skip very common tags
      for (var a = 0; a < Math.min(group.length, 8); a++) {
        for (var b = a + 1; b < Math.min(group.length, 8); b++) {
          var key = Math.min(group[a].id, group[b].id) + ':' + Math.max(group[a].id, group[b].id);
          if (!tagEdgeSet[key]) {
            tagEdgeSet[key] = true;
            tagEdges.push({ source: group[a], target: group[b], tag: tagKeys[k] });
          }
        }
      }
    }

    // Update HUD stats
    document.getElementById('statNodes').textContent = nodes.length;
    document.getElementById('statEdges').textContent = edges.length + tagEdges.length;
    var totalDecay = 0, totalImp = 0;
    for (var i = 0; i < nodes.length; i++) {
      totalDecay += nodes[i].decay;
      totalImp += nodes[i].importance;
    }
    document.getElementById('statAvgDecay').textContent = ((totalDecay / nodes.length) * 100).toFixed(0) + '%';
    document.getElementById('statAvgImp').textContent = ((totalImp / nodes.length) * 100).toFixed(0) + '%';
  }

  // ---- PHYSICS SIMULATION ----
  function simulate() {
    var n = nodes.length;
    if (n === 0) return;

    // Repulsion (all pairs - use spatial hash for optimization on large sets)
    for (var i = 0; i < n; i++) {
      if (hiddenTypes[nodes[i].type]) continue;
      for (var j = i + 1; j < n; j++) {
        if (hiddenTypes[nodes[j].type]) continue;
        var dx = nodes[j].x - nodes[i].x;
        var dy = nodes[j].y - nodes[i].y;
        var dist = Math.sqrt(dx * dx + dy * dy) || 1;
        if (dist > 500) continue; // skip far pairs
        var force = PHYSICS.repulsion / (dist * dist);
        var fx = (dx / dist) * force;
        var fy = (dy / dist) * force;
        nodes[i].vx -= fx;
        nodes[i].vy -= fy;
        nodes[j].vx += fx;
        nodes[j].vy += fy;
      }
    }

    // Evidence edge attraction
    for (var i = 0; i < edges.length; i++) {
      var e = edges[i];
      if (hiddenTypes[e.source.type] || hiddenTypes[e.target.type]) continue;
      var dx = e.target.x - e.source.x;
      var dy = e.target.y - e.source.y;
      var dist = Math.sqrt(dx * dx + dy * dy) || 1;
      var force = dist * PHYSICS.attraction;
      e.source.vx += (dx / dist) * force;
      e.source.vy += (dy / dist) * force;
      e.target.vx -= (dx / dist) * force;
      e.target.vy -= (dy / dist) * force;
    }

    // Tag edge attraction (weaker)
    for (var i = 0; i < tagEdges.length; i++) {
      var e = tagEdges[i];
      if (hiddenTypes[e.source.type] || hiddenTypes[e.target.type]) continue;
      var dx = e.target.x - e.source.x;
      var dy = e.target.y - e.source.y;
      var dist = Math.sqrt(dx * dx + dy * dy) || 1;
      if (dist < PHYSICS.minDistance) continue;
      var force = dist * PHYSICS.tagAttraction;
      e.source.vx += (dx / dist) * force;
      e.source.vy += (dy / dist) * force;
      e.target.vx -= (dx / dist) * force;
      e.target.vy -= (dy / dist) * force;
    }

    // Centering force + velocity integration
    for (var i = 0; i < n; i++) {
      var node = nodes[i];
      if (hiddenTypes[node.type]) continue;
      node.vx -= node.x * PHYSICS.centering;
      node.vy -= node.y * PHYSICS.centering;
      node.vx *= PHYSICS.damping;
      node.vy *= PHYSICS.damping;
      node.x += node.vx;
      node.y += node.vy;
    }
  }

  // ---- RENDERING ----
  function render() {
    time += 0.016;
    var w = window.innerWidth;
    var h = window.innerHeight;

    ctx.clearRect(0, 0, w, h);

    // Background gradient â€” deep space
    var grad = ctx.createRadialGradient(w / 2, h / 2, 0, w / 2, h / 2, w * 0.7);
    grad.addColorStop(0, '#06060e');
    grad.addColorStop(1, '#020204');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, w, h);

    // Camera interpolation
    camera.x += (targetCamera.x - camera.x) * 0.08;
    camera.y += (targetCamera.y - camera.y) * 0.08;
    camera.zoom += (targetCamera.zoom - camera.zoom) * 0.08;

    ctx.save();
    ctx.translate(w / 2, h / 2);
    ctx.scale(camera.zoom, camera.zoom);
    ctx.translate(-camera.x, -camera.y);

    // Draw tag edges (very faint)
    ctx.lineWidth = 0.5;
    for (var i = 0; i < tagEdges.length; i++) {
      var e = tagEdges[i];
      if (hiddenTypes[e.source.type] || hiddenTypes[e.target.type]) continue;
      var alpha = 0.02 * Math.min(e.source.decay, e.target.decay);
      if (hoveredNode && (e.source === hoveredNode || e.target === hoveredNode)) {
        alpha = 0.12;
      }
      ctx.strokeStyle = 'rgba(255,255,255,' + alpha + ')';
      ctx.beginPath();
      ctx.moveTo(e.source.x, e.source.y);
      ctx.lineTo(e.target.x, e.target.y);
      ctx.stroke();
    }

    // Draw evidence edges (brighter, directional)
    for (var i = 0; i < edges.length; i++) {
      var e = edges[i];
      if (hiddenTypes[e.source.type] || hiddenTypes[e.target.type]) continue;
      var sc = TYPE_COLORS[e.source.type];
      var alpha = 0.08 + 0.05 * Math.min(e.source.importance, e.target.importance);
      if (hoveredNode && (e.source === hoveredNode || e.target === hoveredNode)) {
        alpha = 0.5;
      }
      ctx.strokeStyle = 'rgba(' + sc.r + ',' + sc.g + ',' + sc.b + ',' + alpha + ')';
      ctx.lineWidth = hoveredNode && (e.source === hoveredNode || e.target === hoveredNode) ? 1.5 : 0.8;
      ctx.beginPath();
      ctx.moveTo(e.source.x, e.source.y);
      ctx.lineTo(e.target.x, e.target.y);
      ctx.stroke();
    }

    // Draw nodes
    hoveredNode = null;
    var closestDist = 20 / camera.zoom;

    for (var i = 0; i < nodes.length; i++) {
      var node = nodes[i];
      if (hiddenTypes[node.type]) continue;

      var col = TYPE_COLORS[node.type];
      var pulse = 1 + 0.15 * Math.sin(time * 1.5 + node.pulsePhase);
      var r = node.baseRadius * pulse;
      var alpha = 0.15 + 0.85 * node.decay;

      // Check hover
      var sx = (node.x - camera.x) * camera.zoom + w / 2;
      var sy = (node.y - camera.y) * camera.zoom + h / 2;
      var dx = mouse.x - sx;
      var dy = mouse.y - sy;
      var dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < closestDist) {
        closestDist = dist;
        hoveredNode = node;
      }

      var isHovered = false;
      // We'll set this after the loop

      // Outer glow
      var glowR = r * 3;
      var glow = ctx.createRadialGradient(node.x, node.y, r * 0.5, node.x, node.y, glowR);
      glow.addColorStop(0, 'rgba(' + col.r + ',' + col.g + ',' + col.b + ',' + (0.12 * alpha) + ')');
      glow.addColorStop(1, 'rgba(' + col.r + ',' + col.g + ',' + col.b + ',0)');
      ctx.fillStyle = glow;
      ctx.beginPath();
      ctx.arc(node.x, node.y, glowR, 0, Math.PI * 2);
      ctx.fill();

      // Core
      ctx.fillStyle = 'rgba(' + col.r + ',' + col.g + ',' + col.b + ',' + alpha + ')';
      ctx.beginPath();
      ctx.arc(node.x, node.y, r, 0, Math.PI * 2);
      ctx.fill();

      // Bright center
      ctx.fillStyle = 'rgba(' + Math.min(col.r + 80, 255) + ',' + Math.min(col.g + 80, 255) + ',' + Math.min(col.b + 80, 255) + ',' + (alpha * 0.7) + ')';
      ctx.beginPath();
      ctx.arc(node.x, node.y, r * 0.35, 0, Math.PI * 2);
      ctx.fill();
    }

    // Draw hover highlight
    if (hoveredNode) {
      var hn = hoveredNode;
      var col = TYPE_COLORS[hn.type];
      var r = hn.baseRadius * 1.6;

      // Bright ring
      ctx.strokeStyle = 'rgba(' + col.r + ',' + col.g + ',' + col.b + ',0.6)';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(hn.x, hn.y, r + 4, 0, Math.PI * 2);
      ctx.stroke();

      // Expanded glow
      var glow = ctx.createRadialGradient(hn.x, hn.y, r, hn.x, hn.y, r * 5);
      glow.addColorStop(0, 'rgba(' + col.r + ',' + col.g + ',' + col.b + ',0.15)');
      glow.addColorStop(1, 'rgba(' + col.r + ',' + col.g + ',' + col.b + ',0)');
      ctx.fillStyle = glow;
      ctx.beginPath();
      ctx.arc(hn.x, hn.y, r * 5, 0, Math.PI * 2);
      ctx.fill();

      showDetail(hn);
    } else {
      hideDetail();
    }

    ctx.restore();
  }

  // ---- DETAIL PANEL ----
  var detailPanel = document.getElementById('detailPanel');
  var currentDetailId = null;

  function showDetail(node) {
    if (currentDetailId === node.id) return;
    currentDetailId = node.id;

    var typeNames = { episodic: 'EPISODIC', semantic: 'SEMANTIC', procedural: 'PROCEDURAL', self_model: 'SELF-MODEL' };
    var col = TYPE_COLORS[node.type];
    var colorStr = 'rgb(' + col.r + ',' + col.g + ',' + col.b + ')';

    document.getElementById('detailType').textContent = typeNames[node.type] || node.type;
    document.getElementById('detailType').style.color = colorStr;
    document.getElementById('detailSummary').textContent = node.summary;

    var decayLabel = node.decay > 0.8 ? 'FRESH' : (node.decay > 0.4 ? 'FADING' : 'DECAYED');
    var age = timeSince(node.createdAt);

    document.getElementById('detailMeta').innerHTML =
      '<span>IMP <span class="val">' + (node.importance * 100).toFixed(0) + '%</span></span>' +
      '<span>DECAY <span class="val">' + (node.decay * 100).toFixed(0) + '% ' + decayLabel + '</span></span>' +
      '<span>RECALLS <span class="val">' + node.accessCount + '</span></span>' +
      '<span>AGE <span class="val">' + age + '</span></span>' +
      (node.source ? '<span>SRC <span class="val">' + node.source + '</span></span>' : '');

    var tagsHtml = '';
    for (var i = 0; i < Math.min(node.tags.length, 8); i++) {
      tagsHtml += '<span class="detail-tag">' + node.tags[i] + '</span>';
    }
    document.getElementById('detailTags').innerHTML = tagsHtml;

    if (node.evidenceIds.length > 0) {
      document.getElementById('detailEvidence').innerHTML =
        'EVIDENCE LINKS: <span>' + node.evidenceIds.length + ' source memories</span>';
    } else {
      document.getElementById('detailEvidence').innerHTML = '';
    }

    detailPanel.classList.add('visible');
  }

  function hideDetail() {
    if (!selectedNode) {
      detailPanel.classList.remove('visible');
      currentDetailId = null;
    }
  }

  function timeSince(dateStr) {
    if (!dateStr) return '?';
    var seconds = Math.floor((Date.now() - new Date(dateStr).getTime()) / 1000);
    if (seconds < 60) return seconds + 's';
    var minutes = Math.floor(seconds / 60);
    if (minutes < 60) return minutes + 'm';
    var hours = Math.floor(minutes / 60);
    if (hours < 24) return hours + 'h';
    var days = Math.floor(hours / 24);
    return days + 'd';
  }

  // ---- INTERACTION ----
  canvas.addEventListener('mousemove', function(e) {
    mouse.x = e.clientX;
    mouse.y = e.clientY;
    if (dragging) {
      var dx = (e.clientX - dragStart.x) / camera.zoom;
      var dy = (e.clientY - dragStart.y) / camera.zoom;
      targetCamera.x = dragStart.camX - dx;
      targetCamera.y = dragStart.camY - dy;
    }
  });

  canvas.addEventListener('mousedown', function(e) {
    if (hoveredNode) {
      selectedNode = hoveredNode;
      showDetail(selectedNode);
    } else {
      selectedNode = null;
      dragging = true;
      dragStart.x = e.clientX;
      dragStart.y = e.clientY;
      dragStart.camX = targetCamera.x;
      dragStart.camY = targetCamera.y;
      canvas.style.cursor = 'grabbing';
    }
  });

  canvas.addEventListener('mouseup', function() {
    dragging = false;
    canvas.style.cursor = 'crosshair';
  });

  canvas.addEventListener('wheel', function(e) {
    e.preventDefault();
    var zoomDelta = e.deltaY > 0 ? 0.9 : 1.1;
    targetCamera.zoom = Math.max(0.2, Math.min(5, targetCamera.zoom * zoomDelta));
  }, { passive: false });

  // Touch support
  var lastTouchDist = 0;
  canvas.addEventListener('touchstart', function(e) {
    if (e.touches.length === 1) {
      mouse.x = e.touches[0].clientX;
      mouse.y = e.touches[0].clientY;
      dragging = true;
      dragStart.x = e.touches[0].clientX;
      dragStart.y = e.touches[0].clientY;
      dragStart.camX = targetCamera.x;
      dragStart.camY = targetCamera.y;
    } else if (e.touches.length === 2) {
      var dx = e.touches[0].clientX - e.touches[1].clientX;
      var dy = e.touches[0].clientY - e.touches[1].clientY;
      lastTouchDist = Math.sqrt(dx * dx + dy * dy);
    }
  });

  canvas.addEventListener('touchmove', function(e) {
    e.preventDefault();
    if (e.touches.length === 1 && dragging) {
      mouse.x = e.touches[0].clientX;
      mouse.y = e.touches[0].clientY;
      var dx = (e.touches[0].clientX - dragStart.x) / camera.zoom;
      var dy = (e.touches[0].clientY - dragStart.y) / camera.zoom;
      targetCamera.x = dragStart.camX - dx;
      targetCamera.y = dragStart.camY - dy;
    } else if (e.touches.length === 2) {
      var dx = e.touches[0].clientX - e.touches[1].clientX;
      var dy = e.touches[0].clientY - e.touches[1].clientY;
      var dist = Math.sqrt(dx * dx + dy * dy);
      if (lastTouchDist > 0) {
        var scale = dist / lastTouchDist;
        targetCamera.zoom = Math.max(0.2, Math.min(5, targetCamera.zoom * scale));
      }
      lastTouchDist = dist;
    }
  }, { passive: false });

  canvas.addEventListener('touchend', function() {
    dragging = false;
    lastTouchDist = 0;
  });

  // ---- CONTROLS ----
  window.toggleType = function(type) {
    hiddenTypes[type] = !hiddenTypes[type];
    var item = document.querySelector('.legend-item[data-type="' + type + '"]');
    if (item) item.classList.toggle('disabled');
  };

  window.zoomIn = function() {
    targetCamera.zoom = Math.min(5, targetCamera.zoom * 1.3);
  };

  window.zoomOut = function() {
    targetCamera.zoom = Math.max(0.2, targetCamera.zoom * 0.7);
  };

  window.resetView = function() {
    targetCamera.x = 0;
    targetCamera.y = 0;
    targetCamera.zoom = 1;
    selectedNode = null;
  };

  // ---- MAIN LOOP ----
  var frameCount = 0;
  function loop() {
    // Run physics (throttle after settling)
    if (frameCount < 600) {
      simulate();
    } else if (frameCount % 3 === 0) {
      simulate();
    }

    render();
    frameCount++;
    requestAnimationFrame(loop);
  }

  // ---- INIT ----
  fetchBrain();
  loop();

  // Refresh data every 2 minutes
  setInterval(fetchBrain, 120000);

})();
</script>
</body>
</html>
