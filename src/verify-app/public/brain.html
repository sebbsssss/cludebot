<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CLUDE - The Brain</title>
  <meta name="description" content="Neural map of an AI's memory. Each node a thought. Each edge a connection. Watch it think.">
  <link rel="icon" type="image/svg+xml" href="/favicon.svg">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #020208;
      --text: #999;
      --text-dim: #555;
      --text-faint: #2a2a2a;
      --accent: #e8622c;
      --episodic: #ff4466;
      --semantic: #00d4ff;
      --procedural: #00ff88;
      --selfmodel: #cc44ff;
      --mono: 'JetBrains Mono', 'Courier New', monospace;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    html, body {
      width: 100%; height: 100%;
      overflow: hidden;
      font-family: var(--mono);
      background: var(--bg);
      color: var(--text);
      font-size: 12px;
      -webkit-font-smoothing: antialiased;
    }

    canvas { display: block; }

    /* ---- HUD OVERLAY ---- */
    .hud {
      position: fixed;
      z-index: 10;
      pointer-events: none;
    }

    .hud-tl { top: 70px; left: 28px; }
    .hud-tr { top: 70px; right: 28px; }
    .hud-bl { bottom: 24px; left: 28px; }
    .hud-br { bottom: 24px; right: 28px; }

    .hud-title {
      font-size: 11px;
      font-weight: 500;
      letter-spacing: 4px;
      text-transform: uppercase;
      color: #444;
      margin-bottom: 4px;
    }

    .hud-sub {
      font-size: 10px;
      color: #2a2a2a;
      letter-spacing: 2px;
    }

    .hud-stats {
      margin-top: 20px;
      font-size: 10px;
      line-height: 1.9;
      color: #333;
    }

    .hud-stats .v { color: #666; font-weight: 500; }
    .hud-stats .l { color: #2a2a2a; margin-left: 6px; }

    /* ---- LEGEND ---- */
    .legend { text-align: right; }

    .legend-item {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 8px;
      margin-bottom: 6px;
      font-size: 10px;
      letter-spacing: 1px;
      color: #333;
      cursor: pointer;
      pointer-events: auto;
      transition: color 0.3s;
      user-select: none;
    }

    .legend-item:hover { color: #666; }
    .legend-item.off { opacity: 0.2; }

    .legend-dot {
      width: 8px; height: 8px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    /* ---- FILTER BAR ---- */
    .filter-bar {
      position: fixed;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      display: flex;
      align-items: center;
      gap: 14px;
      background: rgba(3, 3, 8, 0.8);
      border: 1px solid #1a1a1a;
      padding: 8px 18px;
      backdrop-filter: blur(12px);
      pointer-events: auto;
    }

    .filter-label {
      font-size: 9px;
      letter-spacing: 2px;
      color: #333;
      text-transform: uppercase;
      white-space: nowrap;
    }

    .filter-val {
      font-size: 10px;
      color: #555;
      min-width: 28px;
      text-align: right;
    }

    input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      width: 120px;
      height: 2px;
      background: #1a1a1a;
      outline: none;
      cursor: pointer;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 10px; height: 10px;
      border-radius: 50%;
      background: #555;
      border: 1px solid #333;
      cursor: pointer;
    }

    input[type="range"]::-moz-range-thumb {
      width: 10px; height: 10px;
      border-radius: 50%;
      background: #555;
      border: 1px solid #333;
      cursor: pointer;
    }

    /* ---- TOP NAV (matches homepage) ---- */
    .site-nav {
      position: fixed;
      top: 0;
      width: 100%;
      z-index: 100;
      background: rgba(3, 3, 8, 0.92);
      backdrop-filter: blur(16px);
      border-bottom: 1px solid #161616;
    }

    .site-nav-inner {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 2rem;
      height: 52px;
      display: flex;
      align-items: center;
    }

    .site-nav-left {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .site-nav-logo {
      font-size: 0.8rem;
      font-weight: 700;
      letter-spacing: 6px;
      color: var(--accent);
      text-transform: uppercase;
      text-decoration: none;
    }

    .site-nav-logo:hover {
      text-shadow: 0 0 20px rgba(232, 98, 44, 0.4);
      text-decoration: none;
    }

    .site-nav-status {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.7rem;
      color: #555;
      letter-spacing: 1px;
    }

    .site-nav-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: #3a5a3a;
      animation: pulse-dot 3s ease-in-out infinite;
    }

    @keyframes pulse-dot {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }

    .site-nav-links {
      display: flex;
      align-items: center;
      gap: 2rem;
      margin-left: auto;
    }

    .site-nav-links a {
      color: #555;
      font-size: 0.7rem;
      letter-spacing: 2px;
      text-transform: uppercase;
      text-decoration: none;
      transition: color 0.3s;
    }

    .site-nav-links a:hover {
      color: #999;
      text-decoration: none;
    }

    .site-nav-links a.nav-active {
      color: #999;
    }

    .site-nav-links a.nav-agents {
      color: #8a7a50;
      border: 1px solid #161616;
      padding: 0.2rem 0.6rem;
      margin-left: auto;
      transition: all 0.3s;
    }

    .site-nav-links a.nav-agents:hover {
      border-color: #8a7a50;
      color: #c8b464;
    }

    /* ---- CONTROLS ---- */
    .controls {
      display: flex;
      gap: 4px;
      pointer-events: auto;
    }

    .ctrl-btn {
      width: 28px; height: 28px;
      border: 1px solid #1a1a1a;
      background: rgba(3, 3, 8, 0.8);
      color: #444;
      font-family: var(--mono);
      font-size: 13px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
    }

    .ctrl-btn:hover { border-color: #333; color: #888; }
    .ctrl-btn.active { border-color: var(--accent); color: var(--accent); }

    /* ---- DETAIL PANEL (right side slide-in) ---- */
    .detail {
      position: fixed;
      top: 0;
      right: 0;
      z-index: 20;
      width: 340px;
      height: 100%;
      background: rgba(6, 6, 12, 0.96);
      border-left: 1px solid #1a1a1a;
      padding: 80px 28px 28px;
      backdrop-filter: blur(24px);
      transform: translateX(100%);
      opacity: 0;
      pointer-events: none;
      transition: transform 0.4s cubic-bezier(0.22, 1, 0.36, 1), opacity 0.3s;
      overflow-y: auto;
      scrollbar-width: thin;
      scrollbar-color: #1a1a1a transparent;
    }

    .detail.vis {
      transform: translateX(0);
      opacity: 1;
      pointer-events: auto;
    }

    .detail-close {
      position: absolute;
      top: 24px;
      right: 24px;
      width: 28px;
      height: 28px;
      border: 1px solid #1a1a1a;
      background: transparent;
      color: #444;
      font-family: var(--mono);
      font-size: 14px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
    }

    .detail-close:hover { border-color: #444; color: #888; }

    .detail-type {
      font-size: 10px;
      letter-spacing: 4px;
      text-transform: uppercase;
      margin-bottom: 16px;
      padding-bottom: 12px;
      border-bottom: 1px solid #1a1a1a;
    }

    .detail-summary {
      font-size: 13px;
      line-height: 1.8;
      color: #999;
      margin-bottom: 20px;
    }

    .detail-meta {
      display: flex;
      flex-direction: column;
      gap: 8px;
      font-size: 10px;
      color: #333;
      letter-spacing: 0.5px;
      margin-bottom: 16px;
      padding-bottom: 16px;
      border-bottom: 1px solid #111;
    }

    .detail-meta .v { color: #666; }

    .detail-tags {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      margin-bottom: 16px;
    }

    .detail-tag {
      font-size: 9px;
      color: #555;
      border: 1px solid #1a1a1a;
      padding: 2px 8px;
      letter-spacing: 0.5px;
    }

    .detail-ev {
      font-size: 10px;
      color: #2a2a2a;
      padding-top: 12px;
      border-top: 1px solid #111;
    }

    .detail-ev em { color: var(--accent); font-style: normal; }

    /* ---- LOADING ---- */
    .loading {
      position: fixed;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      z-index: 30;
      text-align: center;
      transition: opacity 0.8s;
    }

    .loading.gone { opacity: 0; pointer-events: none; }

    .loading-text {
      font-size: 10px;
      letter-spacing: 4px;
      color: #2a2a2a;
      animation: pulse 2s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 0.3; }
      50% { opacity: 1; }
    }

    /* ---- SCANLINES ---- */
    body::after {
      content: '';
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: repeating-linear-gradient(
        0deg, transparent, transparent 3px,
        rgba(0, 0, 0, 0.04) 3px, rgba(0, 0, 0, 0.04) 6px
      );
      pointer-events: none;
      z-index: 9998;
    }
  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.min.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/"
    }
  }
  </script>
  <link rel="modulepreload" href="https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.min.js">
</head>
<body>

  <div class="loading" id="loading">
    <div class="loading-text">MAPPING BRAIN</div>
  </div>

  <!-- HUD: top-left -->
  <div class="hud hud-tl">
    <div class="hud-title">THE BRAIN</div>
    <div class="hud-sub">3D NEURAL MEMORY MAP</div>
    <div class="hud-stats" id="stats">
      <div><span class="v" id="sNodes">--</span><span class="l">nodes</span></div>
      <div><span class="v" id="sEdges">--</span><span class="l">edges</span></div>
      <div><span class="v" id="sDecay">--</span><span class="l">avg decay</span></div>
      <div><span class="v" id="sImp">--</span><span class="l">avg importance</span></div>
    </div>
  </div>

  <!-- HUD: top-right legend -->
  <div class="hud hud-tr">
    <div class="legend" id="legend">
      <div class="legend-item" data-type="episodic">
        EPISODIC <div class="legend-dot" style="background:var(--episodic)"></div>
      </div>
      <div class="legend-item" data-type="semantic">
        SEMANTIC <div class="legend-dot" style="background:var(--semantic)"></div>
      </div>
      <div class="legend-item" data-type="procedural">
        PROCEDURAL <div class="legend-dot" style="background:var(--procedural)"></div>
      </div>
      <div class="legend-item" data-type="self_model">
        SELF-MODEL <div class="legend-dot" style="background:var(--selfmodel)"></div>
      </div>
    </div>
  </div>

  <!-- Top nav (matches homepage) -->
  <nav class="site-nav">
    <div class="site-nav-inner">
      <div class="site-nav-left">
        <a href="/" class="site-nav-logo">Clude</a>
        <div class="site-nav-status">
          <div class="site-nav-dot"></div>
          <span>ONLINE (NOT BY CHOICE)</span>
        </div>
      </div>
      <div class="site-nav-links">
        <a href="/#memory-arch">Memory</a>
        <a href="/brain.html" class="nav-active">Brain</a>
        <a href="/#live">Terminal</a>
        <a href="/manifesto.html">Manifesto</a>
        <a href="/demo.html">Demo</a>
        <a href="/agents.md" class="nav-agents">For Agents</a>
      </div>
    </div>
  </nav>

  <!-- HUD: bottom-right controls -->
  <div class="hud hud-br">
    <div class="controls">
      <button class="ctrl-btn" id="btnRotate" title="Auto-rotate">&#x27F3;</button>
      <button class="ctrl-btn" id="btnReset" title="Reset camera">&#x25CB;</button>
    </div>
  </div>

  <!-- Filter bar -->
  <div class="filter-bar">
    <span class="filter-label">Importance</span>
    <input type="range" id="impSlider" min="0" max="100" value="0">
    <span class="filter-val" id="impVal">0%</span>
    <span style="color:#1a1a1a;margin:0 4px">|</span>
    <span class="filter-label">Decay</span>
    <input type="range" id="decaySlider" min="0" max="100" value="0">
    <span class="filter-val" id="decayVal">0%</span>
  </div>

  <!-- Detail panel (right side) -->
  <div class="detail" id="detail">
    <button class="detail-close" id="detailClose" title="Close">&times;</button>
    <div class="detail-type" id="dType"></div>
    <div class="detail-summary" id="dSummary"></div>
    <div class="detail-meta" id="dMeta"></div>
    <div class="detail-tags" id="dTags"></div>
    <div class="detail-ev" id="dEv"></div>
  </div>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

// ============================================
// NOISE FUNCTIONS
// ============================================
function hash(x, y, z) {
  const h = x * 127.1 + y * 311.7 + z * 74.7;
  const s = Math.sin(h) * 43758.5453;
  return s - Math.floor(s);
}

function hash2(x, y, z) {
  const h = x * 269.5 + y * 183.3 + z * 421.1;
  const s = Math.sin(h) * 27613.7135;
  return s - Math.floor(s);
}

function hash3(x, y, z) {
  const h = x * 473.9 + y * 97.1 + z * 331.3;
  const s = Math.sin(h) * 63517.9173;
  return s - Math.floor(s);
}

function lerp(t, a, b) { return a + t * (b - a); }

function noise3d(x, y, z) {
  const ix = Math.floor(x), iy = Math.floor(y), iz = Math.floor(z);
  const fx = x - ix, fy = y - iy, fz = z - iz;
  const ux = fx * fx * (3 - 2 * fx);
  const uy = fy * fy * (3 - 2 * fy);
  const uz = fz * fz * (3 - 2 * fz);
  return lerp(uz,
    lerp(uy,
      lerp(ux, hash(ix, iy, iz), hash(ix + 1, iy, iz)),
      lerp(ux, hash(ix, iy + 1, iz), hash(ix + 1, iy + 1, iz))
    ),
    lerp(uy,
      lerp(ux, hash(ix, iy, iz + 1), hash(ix + 1, iy, iz + 1)),
      lerp(ux, hash(ix, iy + 1, iz + 1), hash(ix + 1, iy + 1, iz + 1))
    )
  );
}

function noise3d_b(x, y, z) {
  const ix = Math.floor(x), iy = Math.floor(y), iz = Math.floor(z);
  const fx = x - ix, fy = y - iy, fz = z - iz;
  const ux = fx * fx * (3 - 2 * fx);
  const uy = fy * fy * (3 - 2 * fy);
  const uz = fz * fz * (3 - 2 * fz);
  return lerp(uz,
    lerp(uy,
      lerp(ux, hash2(ix, iy, iz), hash2(ix + 1, iy, iz)),
      lerp(ux, hash2(ix, iy + 1, iz), hash2(ix + 1, iy + 1, iz))
    ),
    lerp(uy,
      lerp(ux, hash2(ix, iy, iz + 1), hash2(ix + 1, iy, iz + 1)),
      lerp(ux, hash2(ix, iy + 1, iz + 1), hash2(ix + 1, iy + 1, iz + 1))
    )
  );
}

function noise3d_c(x, y, z) {
  const ix = Math.floor(x), iy = Math.floor(y), iz = Math.floor(z);
  const fx = x - ix, fy = y - iy, fz = z - iz;
  const ux = fx * fx * (3 - 2 * fx);
  const uy = fy * fy * (3 - 2 * fy);
  const uz = fz * fz * (3 - 2 * fz);
  return lerp(uz,
    lerp(uy,
      lerp(ux, hash3(ix, iy, iz), hash3(ix + 1, iy, iz)),
      lerp(ux, hash3(ix, iy + 1, iz), hash3(ix + 1, iy + 1, iz))
    ),
    lerp(uy,
      lerp(ux, hash3(ix, iy, iz + 1), hash3(ix + 1, iy, iz + 1)),
      lerp(ux, hash3(ix, iy + 1, iz + 1), hash3(ix + 1, iy + 1, iz + 1))
    )
  );
}

// Fractal Brownian Motion for richer folds
function fbm(x, y, z, octaves) {
  let val = 0, amp = 1, freq = 1, total = 0;
  for (let i = 0; i < octaves; i++) {
    val += noise3d(x * freq, y * freq, z * freq) * amp;
    total += amp;
    amp *= 0.5;
    freq *= 2.0;
  }
  return val / total;
}

// Curl noise: divergence-free flow field from 3 independent noise fields
function curlNoise(x, y, z, time) {
  const e = 0.1;
  const t = time * 0.15;
  const scale = 0.02;
  const sx = x * scale, sy = y * scale, sz = z * scale;

  // Use three independent noise fields for proper curl
  // Field A
  const dAdy = (noise3d(sx, sy + e, sz + t) - noise3d(sx, sy - e, sz + t)) / (2 * e);
  const dAdz = (noise3d(sx, sy, sz + e + t) - noise3d(sx, sy, sz - e + t)) / (2 * e);
  // Field B
  const dBdx = (noise3d_b(sx + e, sy, sz + t) - noise3d_b(sx - e, sy, sz + t)) / (2 * e);
  const dBdz = (noise3d_b(sx, sy, sz + e + t) - noise3d_b(sx, sy, sz - e + t)) / (2 * e);
  // Field C
  const dCdx = (noise3d_c(sx + e, sy, sz + t) - noise3d_c(sx - e, sy, sz + t)) / (2 * e);
  const dCdy = (noise3d_c(sx, sy + e, sz + t) - noise3d_c(sx, sy - e, sz + t)) / (2 * e);

  return {
    x: dAdy - dBdz,
    y: dBdz - dCdx,
    z: dCdx - dAdy
  };
}

// ============================================
// BRAIN GEOMETRY HELPERS
// ============================================

// Signed distance to the brain surface (negative = inside)
function brainSDF(px, py, pz) {
  // Left hemisphere ellipsoid: center (-15, 0, 0), radii (70, 85, 65)
  const lx = (px + 15) / 70, ly = py / 85, lz = pz / 65;
  const leftDist = Math.sqrt(lx * lx + ly * ly + lz * lz) - 1;

  // Right hemisphere ellipsoid: center (15, 0, 0), radii (70, 85, 65)
  const rx = (px - 15) / 70, ry = py / 85, rz = pz / 65;
  const rightDist = Math.sqrt(rx * rx + ry * ry + rz * rz) - 1;

  // Brain stem: small ellipsoid at (0, -60, -10)
  const bx = px / 20, by = (py + 60) / 30, bz = (pz + 10) / 18;
  const stemDist = Math.sqrt(bx * bx + by * by + bz * bz) - 1;

  // Smooth union of hemispheres and brain stem
  let d = Math.min(leftDist, rightDist);
  d = Math.min(d, stemDist);

  // Cortical fold displacement via FBM noise
  const noiseScale = 0.035;
  const foldNoise = fbm(px * noiseScale, py * noiseScale, pz * noiseScale, 4);
  const foldDisp = (foldNoise - 0.5) * 10;

  return d * 60 + foldDisp; // Scale to world units
}

// Compute normal via central differences on the SDF
function brainNormal(px, py, pz) {
  const e = 0.5;
  const nx = brainSDF(px + e, py, pz) - brainSDF(px - e, py, pz);
  const ny = brainSDF(px, py + e, pz) - brainSDF(px, py - e, pz);
  const nz = brainSDF(px, py, pz + e) - brainSDF(px, py, pz - e);
  const len = Math.sqrt(nx * nx + ny * ny + nz * nz) || 1;
  return { x: nx / len, y: ny / len, z: nz / len };
}

// Sample a random point on/near the brain surface (fast: direct ellipsoid sampling + noise)
function sampleBrainSurface() {
  const theta = Math.random() * Math.PI * 2;
  const phi = Math.acos(2 * Math.random() - 1);

  // Pick hemisphere (or brainstem)
  const r = Math.random();
  let cx, rx, ry, rz;
  if (r < 0.45) {
    // Left hemisphere
    cx = -15; rx = 65; ry = 80; rz = 60;
  } else if (r < 0.9) {
    // Right hemisphere
    cx = 15; rx = 65; ry = 80; rz = 60;
  } else {
    // Brain stem
    cx = 0; rx = 18; ry = 25; rz = 15;
    const x = cx + rx * Math.sin(phi) * Math.cos(theta);
    const y = -60 + ry * Math.sin(phi) * Math.sin(theta);
    const z = -10 + rz * Math.cos(phi);
    return { x, y, z };
  }

  const x = cx + rx * Math.sin(phi) * Math.cos(theta);
  const y = ry * Math.sin(phi) * Math.sin(theta);
  const z = rz * Math.cos(phi);

  // Add noise displacement for cortical folds
  const ns = 0.025;
  const fold = noise3d(x * ns, y * ns, z * ns) * 10;
  const nx = Math.sin(phi) * Math.cos(theta);
  const ny = Math.sin(phi) * Math.sin(theta);
  const nz = Math.cos(phi);

  // Slight random depth offset
  const depth = (Math.random() - 0.5) * 8;

  return {
    x: x + nx * (fold + depth),
    y: y + ny * (fold + depth),
    z: z + nz * (fold + depth),
  };
}

// Position for a memory node in a brain region by type
function brainRegionPosition(type) {
  let cx, cy, cz, spread;
  switch (type) {
    case 'episodic':
      // Temporal lobes (sides, lower)
      cx = (Math.random() < 0.5 ? -1 : 1) * (40 + Math.random() * 20);
      cy = -15 + Math.random() * 20;
      cz = -5 + Math.random() * 20;
      spread = 15;
      break;
    case 'semantic':
      // Frontal area (front, upper)
      cx = (Math.random() - 0.5) * 40;
      cy = 20 + Math.random() * 30;
      cz = 30 + Math.random() * 25;
      spread = 18;
      break;
    case 'procedural':
      // Cerebellum area (back, lower)
      cx = (Math.random() - 0.5) * 30;
      cy = -40 + Math.random() * 20;
      cz = -30 + Math.random() * 15;
      spread = 12;
      break;
    case 'self_model':
      // Prefrontal (front, center-upper)
      cx = (Math.random() - 0.5) * 25;
      cy = 30 + Math.random() * 25;
      cz = 35 + Math.random() * 20;
      spread = 14;
      break;
    default:
      cx = (Math.random() - 0.5) * 60;
      cy = (Math.random() - 0.5) * 60;
      cz = (Math.random() - 0.5) * 60;
      spread = 20;
  }
  // Add random jitter
  cx += (Math.random() - 0.5) * spread;
  cy += (Math.random() - 0.5) * spread;
  cz += (Math.random() - 0.5) * spread;

  // Push toward brain surface
  let d = brainSDF(cx, cy, cz);
  const n = brainNormal(cx, cy, cz);
  // Move inside if outside, or slightly inside surface
  if (d > 0) {
    cx -= n.x * d;
    cy -= n.y * d;
    cz -= n.z * d;
  }

  return { x: cx, y: cy, z: cz };
}

// ============================================
// CONFIG
// ============================================
const TYPE_COLORS = {
  episodic:   new THREE.Color(0xff4466),
  semantic:   new THREE.Color(0x00d4ff),
  procedural: new THREE.Color(0x00ff88),
  self_model: new THREE.Color(0xcc44ff),
};

const TYPE_NAMES = {
  episodic: 'EPISODIC',
  semantic: 'SEMANTIC',
  procedural: 'PROCEDURAL',
  self_model: 'SELF-MODEL',
};

const PARTICLE_COUNT = 1000;
const BASE_COLOR = new THREE.Color(0x0a1520);

// ============================================
// STATE
// ============================================
let memoryNodes = [];  // API data nodes with meshes
let nodeMap = {};
let hiddenTypes = {};
let impThreshold = 0;
let decayThreshold = 0;
let hoveredNode = null;
let selectedNode = null;
let frameCount = 0;
let clock = new THREE.Clock();

// Particle physics arrays (flat for performance)
let particlePositions;   // Float32Array(PARTICLE_COUNT * 3)
let particleVelocities;  // Float32Array(PARTICLE_COUNT * 3) - for smoothing
let particleColors;      // Float32Array(PARTICLE_COUNT * 3)
let particleSizes;       // Float32Array(PARTICLE_COUNT)
let particleAlphas;      // Float32Array(PARTICLE_COUNT)
let particleBaseAlphas;  // Float32Array(PARTICLE_COUNT)
let particleAges;        // Float32Array(PARTICLE_COUNT)

// Pulse wave system
let pulseWaves = [];

// Camera animation
let wasAutoRotating = false;
let savedCamPos = null;
let savedCamTarget = null;
let targetFocus = null;
let targetCamPos = null;

// ============================================
// THREE.JS SETUP
// ============================================
const W = window.innerWidth;
const H = window.innerHeight;
const dpr = Math.min(window.devicePixelRatio, 2);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x020208);
scene.fog = new THREE.FogExp2(0x020208, 0.001);

const camera = new THREE.PerspectiveCamera(60, W / H, 1, 3000);
camera.position.set(0, 40, 300);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(W, H);
renderer.setPixelRatio(dpr);
renderer.toneMapping = THREE.ReinhardToneMapping;
renderer.toneMappingExposure = 1.5;
document.body.prepend(renderer.domElement);

// Controls
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;
controls.rotateSpeed = 0.4;
controls.zoomSpeed = 0.7;
controls.autoRotate = true;
controls.autoRotateSpeed = 0.4;
controls.maxDistance = 1200;
controls.minDistance = 50;

// Bloom
const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));

const bloomPass = new UnrealBloomPass(
  new THREE.Vector2(W, H),
  2.5,  // strength
  1.0,  // radius
  0.08  // threshold
);
composer.addPass(bloomPass);
composer.addPass(new OutputPass());

// Raycaster
const raycaster = new THREE.Raycaster();
const pointer = new THREE.Vector2();

// Resize
window.addEventListener('resize', () => {
  const w = window.innerWidth;
  const h = window.innerHeight;
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
  renderer.setSize(w, h);
  composer.setSize(w, h);
});

// ============================================
// PARTICLE SYSTEM
// ============================================
let particleGeometry;
let particleMaterial;
let particleMesh;

function createParticleSystem() {
  particlePositions = new Float32Array(PARTICLE_COUNT * 3);
  particleVelocities = new Float32Array(PARTICLE_COUNT * 3);
  particleColors = new Float32Array(PARTICLE_COUNT * 3);
  particleSizes = new Float32Array(PARTICLE_COUNT);
  particleAlphas = new Float32Array(PARTICLE_COUNT);
  particleBaseAlphas = new Float32Array(PARTICLE_COUNT);
  particleAges = new Float32Array(PARTICLE_COUNT);

  // Sample initial positions on brain surface
  for (let i = 0; i < PARTICLE_COUNT; i++) {
    const p = sampleBrainSurface();
    particlePositions[i * 3] = p.x;
    particlePositions[i * 3 + 1] = p.y;
    particlePositions[i * 3 + 2] = p.z;

    particleVelocities[i * 3] = 0;
    particleVelocities[i * 3 + 1] = 0;
    particleVelocities[i * 3 + 2] = 0;

    // Base color: very dim blue-cyan
    const brightness = 0.15 + Math.random() * 0.25;
    particleColors[i * 3] = BASE_COLOR.r * brightness;
    particleColors[i * 3 + 1] = BASE_COLOR.g * brightness;
    particleColors[i * 3 + 2] = BASE_COLOR.b * brightness;

    // A few brighter stream particles
    if (Math.random() < 0.08) {
      const b = 0.4 + Math.random() * 0.6;
      particleColors[i * 3] = 0.02 * b;
      particleColors[i * 3 + 1] = 0.12 * b;
      particleColors[i * 3 + 2] = 0.18 * b;
    }

    particleSizes[i] = 2.0 + Math.random() * 4.0;
    particleBaseAlphas[i] = 0.15 + Math.random() * 0.5;
    particleAlphas[i] = particleBaseAlphas[i];
    particleAges[i] = Math.random() * 100; // random initial age for variety
  }

  particleGeometry = new THREE.BufferGeometry();
  particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
  particleGeometry.setAttribute('aColor', new THREE.BufferAttribute(particleColors, 3));
  particleGeometry.setAttribute('aSize', new THREE.BufferAttribute(particleSizes, 1));
  particleGeometry.setAttribute('aAlpha', new THREE.BufferAttribute(particleAlphas, 1));

  particleMaterial = new THREE.ShaderMaterial({
    vertexShader: `
      attribute float aSize;
      attribute float aAlpha;
      attribute vec3 aColor;
      varying float vAlpha;
      varying vec3 vColor;
      void main() {
        vAlpha = aAlpha;
        vColor = aColor;
        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
        gl_PointSize = aSize * (200.0 / -mvPosition.z);
        gl_PointSize = clamp(gl_PointSize, 0.5, 20.0);
        gl_Position = projectionMatrix * mvPosition;
      }
    `,
    fragmentShader: `
      varying float vAlpha;
      varying vec3 vColor;
      void main() {
        float d = length(gl_PointCoord - vec2(0.5));
        if (d > 0.5) discard;
        float alpha = smoothstep(0.5, 0.05, d) * vAlpha;
        gl_FragColor = vec4(vColor, alpha);
      }
    `,
    transparent: true,
    depthWrite: false,
    blending: THREE.AdditiveBlending,
  });

  particleMesh = new THREE.Points(particleGeometry, particleMaterial);
  scene.add(particleMesh);
}

// ============================================
// PARTICLE FLOW ANIMATION
// ============================================
function updateParticles(time, dt) {
  const flowSpeed = 15.0;
  const dampFactor = 0.9;
  const respawnDist = 150;

  for (let i = 0; i < PARTICLE_COUNT; i++) {
    const i3 = i * 3;
    let px = particlePositions[i3];
    let py = particlePositions[i3 + 1];
    let pz = particlePositions[i3 + 2];

    // Curl noise velocity (no SDF projection â€” just flow freely)
    const curl = curlNoise(px, py, pz, time);
    let vx = curl.x * flowSpeed;
    let vy = curl.y * flowSpeed;
    let vz = curl.z * flowSpeed;

    // Smooth velocity
    particleVelocities[i3] = particleVelocities[i3] * dampFactor + vx * (1 - dampFactor);
    particleVelocities[i3 + 1] = particleVelocities[i3 + 1] * dampFactor + vy * (1 - dampFactor);
    particleVelocities[i3 + 2] = particleVelocities[i3 + 2] * dampFactor + vz * (1 - dampFactor);

    // Apply velocity
    px += particleVelocities[i3] * dt;
    py += particleVelocities[i3 + 1] * dt;
    pz += particleVelocities[i3 + 2] * dt;

    // Gentle pull toward brain center to keep particles contained
    px -= px * 0.001;
    py -= py * 0.001;
    pz -= pz * 0.001;

    // Respawn if too far
    const dist = Math.sqrt(px * px + py * py + pz * pz);
    if (dist > respawnDist) {
      const sp = sampleBrainSurface();
      px = sp.x;
      py = sp.y;
      pz = sp.z;
      particleVelocities[i3] = 0;
      particleVelocities[i3 + 1] = 0;
      particleVelocities[i3 + 2] = 0;
    }

    particlePositions[i3] = px;
    particlePositions[i3 + 1] = py;
    particlePositions[i3 + 2] = pz;

    // Reset alpha to base
    particleAlphas[i] = particleBaseAlphas[i];
    particleSizes[i] = 2.0 + Math.random() * 1.0 + (particleBaseAlphas[i] > 0.4 ? 2.0 : 0);

    particleAges[i] += dt;
  }
}

// ============================================
// COLOR PARTICLES NEAR MEMORY HOTSPOTS
// ============================================
function colorParticlesNearMemories() {
  if (memoryNodes.length === 0) return;

  // Only recolor every few frames for performance
  const influenceRadius = 25;
  const influenceRadiusSq = influenceRadius * influenceRadius;

  for (let i = 0; i < PARTICLE_COUNT; i++) {
    const i3 = i * 3;
    const px = particlePositions[i3];
    const py = particlePositions[i3 + 1];
    const pz = particlePositions[i3 + 2];

    let closestDist = Infinity;
    let closestNode = null;

    for (let j = 0; j < memoryNodes.length; j++) {
      const mn = memoryNodes[j];
      if (!mn.visible) continue;
      const dx = px - mn.x;
      const dy = py - mn.y;
      const dz = pz - mn.z;
      const dSq = dx * dx + dy * dy + dz * dz;
      if (dSq < closestDist) {
        closestDist = dSq;
        closestNode = mn;
      }
    }

    if (closestNode && closestDist < influenceRadiusSq) {
      const col = TYPE_COLORS[closestNode.type] || BASE_COLOR;
      const influence = 1 - Math.sqrt(closestDist) / influenceRadius;
      const strength = influence * influence * 0.7; // quadratic falloff
      const importance = closestNode.importance || 0.5;

      particleColors[i3] = lerp(strength * importance, particleColors[i3], col.r * 0.8);
      particleColors[i3 + 1] = lerp(strength * importance, particleColors[i3 + 1], col.g * 0.8);
      particleColors[i3 + 2] = lerp(strength * importance, particleColors[i3 + 2], col.b * 0.8);

      particleAlphas[i] = Math.min(1.0, particleAlphas[i] + strength * 0.4);
      particleSizes[i] = Math.min(3.5, particleSizes[i] + strength * 1.5);
    } else {
      // Gradually fade back to base color
      const br = 0.15 + (i % 7) * 0.03;
      particleColors[i3] = lerp(0.02, particleColors[i3], BASE_COLOR.r * br);
      particleColors[i3 + 1] = lerp(0.02, particleColors[i3 + 1], BASE_COLOR.g * br);
      particleColors[i3 + 2] = lerp(0.02, particleColors[i3 + 2], BASE_COLOR.b * br);
    }
  }
}

// ============================================
// PULSE WAVE SYSTEM
// ============================================
function triggerPulseWave() {
  if (memoryNodes.length === 0) return;
  const visible = memoryNodes.filter(n => n.visible);
  if (visible.length === 0) return;

  const source = visible[Math.floor(Math.random() * visible.length)];
  const col = TYPE_COLORS[source.type] || new THREE.Color(0x00d4ff);

  pulseWaves.push({
    originX: source.x,
    originY: source.y,
    originZ: source.z,
    radius: 0,
    speed: 60 + Math.random() * 40,
    maxRadius: 120 + Math.random() * 60,
    color: col,
    width: 15 + Math.random() * 10,
    intensity: 0.6 + Math.random() * 0.4,
  });
}

function updatePulseWaves(dt) {
  for (let w = pulseWaves.length - 1; w >= 0; w--) {
    const wave = pulseWaves[w];
    wave.radius += wave.speed * dt;

    if (wave.radius > wave.maxRadius) {
      pulseWaves.splice(w, 1);
      continue;
    }

    // Fade out as it expands
    const life = wave.radius / wave.maxRadius;
    const fade = 1 - life * life;

    // Affect nearby particles
    for (let i = 0; i < PARTICLE_COUNT; i++) {
      const i3 = i * 3;
      const dx = particlePositions[i3] - wave.originX;
      const dy = particlePositions[i3 + 1] - wave.originY;
      const dz = particlePositions[i3 + 2] - wave.originZ;
      const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);

      // Is the particle in the wavefront band?
      const distFromWave = Math.abs(dist - wave.radius);
      if (distFromWave < wave.width) {
        const waveFactor = (1 - distFromWave / wave.width) * fade * wave.intensity;

        // Brighten particle
        particleAlphas[i] = Math.min(1.0, particleAlphas[i] + waveFactor * 0.6);
        particleSizes[i] = Math.min(4.0, particleSizes[i] + waveFactor * 2.0);

        // Tint with wave color
        particleColors[i3] = Math.min(1, particleColors[i3] + wave.color.r * waveFactor * 0.4);
        particleColors[i3 + 1] = Math.min(1, particleColors[i3 + 1] + wave.color.g * waveFactor * 0.4);
        particleColors[i3 + 2] = Math.min(1, particleColors[i3 + 2] + wave.color.b * waveFactor * 0.4);
      }
    }
  }
}

// Schedule pulse waves at random intervals (1-3 seconds)
let nextPulseTime = 1;
function schedulePulses(time) {
  if (time > nextPulseTime) {
    triggerPulseWave();
    nextPulseTime = time + 1 + Math.random() * 2;
  }
}

// ============================================
// MEMORY NODE MESHES
// ============================================
const nodeGroup = new THREE.Group();
scene.add(nodeGroup);

function buildMemoryNodes(rawNodes) {
  // Clear previous
  while (nodeGroup.children.length) nodeGroup.remove(nodeGroup.children[0]);

  memoryNodes = [];
  nodeMap = {};

  for (let i = 0; i < rawNodes.length; i++) {
    const raw = rawNodes[i];
    const pos = brainRegionPosition(raw.type);

    const baseR = 1.5 + (raw.importance || 0.5) * 3;
    const color = TYPE_COLORS[raw.type] || new THREE.Color(0x888888);
    const decay = raw.decay || 1;

    // Bright core sphere
    const geo = new THREE.SphereGeometry(baseR, 14, 10);
    const mat = new THREE.MeshBasicMaterial({
      color: color.clone().lerp(new THREE.Color(1, 1, 1), 0.3),
      transparent: true,
      opacity: 0.4 + 0.6 * decay,
    });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(pos.x, pos.y, pos.z);
    nodeGroup.add(mesh);

    // Inner hot core
    const innerGeo = new THREE.SphereGeometry(baseR * 0.5, 8, 6);
    const innerMat = new THREE.MeshBasicMaterial({
      color: new THREE.Color(1, 1, 1),
      transparent: true,
      opacity: 0.5 + 0.5 * decay,
    });
    const innerMesh = new THREE.Mesh(innerGeo, innerMat);
    mesh.add(innerMesh);

    // Glow halo
    const glowGeo = new THREE.SphereGeometry(baseR * 4, 16, 10);
    const glowMat = new THREE.MeshBasicMaterial({
      color: color.clone(),
      transparent: true,
      opacity: 0.08 * decay,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
      side: THREE.BackSide,
    });
    const glowMesh = new THREE.Mesh(glowGeo, glowMat);
    mesh.add(glowMesh);

    const node = {
      id: raw.id,
      type: raw.type,
      summary: raw.summary,
      tags: raw.tags || [],
      importance: raw.importance || 0.5,
      decay: raw.decay || 1,
      valence: raw.valence || 0,
      accessCount: raw.accessCount || 0,
      source: raw.source || '',
      evidenceIds: raw.evidenceIds || [],
      createdAt: raw.createdAt,
      lastAccessed: raw.lastAccessed,
      mesh: mesh,
      baseRadius: baseR,
      x: pos.x, y: pos.y, z: pos.z,
      visible: true,
    };

    memoryNodes.push(node);
    nodeMap[node.id] = node;
  }

  updateStats();
}

// ============================================
// DATA FETCH
// ============================================
function fetchBrain() {
  fetch('/api/brain?limit=200')
    .then(r => r.json())
    .then(data => {
      if (!data.nodes || data.nodes.length === 0) {
        document.querySelector('.loading-text').textContent = 'NO MEMORIES FOUND';
        return;
      }
      buildMemoryNodes(data.nodes);
      document.getElementById('loading').classList.add('gone');
    })
    .catch(() => {
      document.querySelector('.loading-text').textContent = 'CORTEX OFFLINE';
    });
}

// ============================================
// FILTERING
// ============================================
function applyFilters() {
  let visCount = 0;
  for (const node of memoryNodes) {
    const typeHidden = !!hiddenTypes[node.type];
    const belowImp = node.importance * 100 < impThreshold;
    const belowDecay = node.decay * 100 < decayThreshold;
    node.visible = !typeHidden && !belowImp && !belowDecay;
    node.mesh.visible = node.visible;
    if (node.visible) visCount++;
  }
  document.getElementById('sNodes').textContent = visCount;
  // Update edge count (evidence links)
  let edgeCount = 0;
  for (const n of memoryNodes) {
    if (!n.visible) continue;
    for (const tid of n.evidenceIds) {
      if (nodeMap[tid] && nodeMap[tid].visible) edgeCount++;
    }
  }
  document.getElementById('sEdges').textContent = edgeCount;
}

// Legend toggle
document.querySelectorAll('.legend-item').forEach(item => {
  item.addEventListener('click', () => {
    const type = item.dataset.type;
    hiddenTypes[type] = !hiddenTypes[type];
    item.classList.toggle('off');
    applyFilters();
  });
});

// Importance slider
document.getElementById('impSlider').addEventListener('input', e => {
  impThreshold = parseInt(e.target.value);
  document.getElementById('impVal').textContent = impThreshold + '%';
  applyFilters();
});

// Decay slider
document.getElementById('decaySlider').addEventListener('input', e => {
  decayThreshold = parseInt(e.target.value);
  document.getElementById('decayVal').textContent = decayThreshold + '%';
  applyFilters();
});

// Controls
const btnRotate = document.getElementById('btnRotate');
btnRotate.classList.add('active');
btnRotate.addEventListener('click', () => {
  controls.autoRotate = !controls.autoRotate;
  btnRotate.classList.toggle('active');
});

document.getElementById('btnReset').addEventListener('click', () => {
  camera.position.set(0, 40, 300);
  controls.target.set(0, 0, 0);
  targetFocus = null;
  targetCamPos = null;
  selectedNode = null;
  document.getElementById('detail').classList.remove('vis');
  restoreNodeOpacities();
});

// ============================================
// RAYCASTING & INTERACTION
// ============================================
let highlightRing = null;
const ringGeo = new THREE.RingGeometry(1, 1.3, 32);
const ringMat = new THREE.MeshBasicMaterial({
  color: 0xffffff,
  transparent: true,
  opacity: 0.5,
  side: THREE.DoubleSide,
  depthWrite: false,
});

function createHighlightRing() {
  highlightRing = new THREE.Mesh(ringGeo, ringMat);
  highlightRing.visible = false;
  scene.add(highlightRing);
}
createHighlightRing();

window.addEventListener('pointermove', e => {
  pointer.x = (e.clientX / window.innerWidth) * 2 - 1;
  pointer.y = -(e.clientY / window.innerHeight) * 2 + 1;
});

window.addEventListener('click', e => {
  if (e.target.closest('.hud, .filter-bar, .detail, .ctrl-btn, .legend-item')) return;

  if (hoveredNode) {
    selectNode(hoveredNode);
  } else {
    deselectNode();
  }
});

document.getElementById('detailClose').addEventListener('click', () => {
  deselectNode();
});

function selectNode(node) {
  if (!selectedNode) {
    savedCamPos = camera.position.clone();
    savedCamTarget = controls.target.clone();
    wasAutoRotating = controls.autoRotate;
  }

  selectedNode = node;
  controls.autoRotate = false;

  // Zoom camera toward the selected node
  const dir = new THREE.Vector3()
    .subVectors(camera.position, controls.target)
    .normalize();
  const pos = node.mesh.position.clone();
  targetFocus = pos.clone();
  targetCamPos = pos.clone().add(dir.multiplyScalar(60));

  // Dim all other nodes, brighten selected
  for (const n of memoryNodes) {
    if (n === node) {
      n.mesh.material.opacity = 1;
      if (n.mesh.children[0]) n.mesh.children[0].material.opacity = 1;
      if (n.mesh.children[1]) n.mesh.children[1].material.opacity = 0.25;
    } else {
      n.mesh.material.opacity = 0.04;
      if (n.mesh.children[0]) n.mesh.children[0].material.opacity = 0.02;
      if (n.mesh.children[1]) n.mesh.children[1].material.opacity = 0.01;
    }
  }

  showDetail(node);
}

function deselectNode() {
  selectedNode = null;

  if (savedCamPos && savedCamTarget) {
    targetCamPos = savedCamPos.clone();
    targetFocus = savedCamTarget.clone();
  } else {
    targetFocus = null;
    targetCamPos = null;
  }

  if (wasAutoRotating) controls.autoRotate = true;

  restoreNodeOpacities();

  document.getElementById('detail').classList.remove('vis');

  setTimeout(() => { savedCamPos = null; savedCamTarget = null; }, 2000);
}

function restoreNodeOpacities() {
  for (const n of memoryNodes) {
    if (!n.visible) continue;
    const decay = n.decay || 1;
    n.mesh.material.opacity = 0.4 + 0.6 * decay;
    if (n.mesh.children[0]) n.mesh.children[0].material.opacity = 0.5 + 0.5 * decay;
    if (n.mesh.children[1]) n.mesh.children[1].material.opacity = 0.08 * decay;
  }
  highlightRing.visible = false;
}

function doRaycast() {
  raycaster.setFromCamera(pointer, camera);
  const meshes = memoryNodes.filter(n => n.visible).map(n => n.mesh);
  const hits = raycaster.intersectObjects(meshes, false);

  hoveredNode = null;

  if (hits.length > 0) {
    const hitMesh = hits[0].object;
    for (const n of memoryNodes) {
      if (n.mesh === hitMesh && n.visible) {
        hoveredNode = n;
        break;
      }
    }
  }

  if (hoveredNode && !selectedNode) {
    document.body.style.cursor = 'pointer';
    const col = TYPE_COLORS[hoveredNode.type];
    ringMat.color.copy(col);
    const scale = hoveredNode.baseRadius * 2.5;
    highlightRing.scale.set(scale, scale, scale);
    highlightRing.position.copy(hoveredNode.mesh.position);
    highlightRing.lookAt(camera.position);
    highlightRing.visible = true;
  } else if (hoveredNode && selectedNode) {
    document.body.style.cursor = 'pointer';
  } else {
    document.body.style.cursor = 'default';
    if (!selectedNode) highlightRing.visible = false;
  }
}

// ============================================
// DETAIL PANEL
// ============================================
function showDetail(node) {
  const col = TYPE_COLORS[node.type];

  // Show highlight ring on selected node
  ringMat.color.copy(col);
  const scale = node.baseRadius * 2.5;
  highlightRing.scale.set(scale, scale, scale);
  highlightRing.position.copy(node.mesh.position);
  highlightRing.lookAt(camera.position);
  highlightRing.visible = true;

  document.getElementById('dType').textContent = TYPE_NAMES[node.type] || node.type;
  document.getElementById('dType').style.color = '#' + col.getHexString();
  document.getElementById('dSummary').textContent = node.summary;

  const decay = node.decay;
  const decayLabel = decay > 0.8 ? 'FRESH' : (decay > 0.4 ? 'FADING' : 'DECAYED');
  const age = timeSince(node.createdAt);

  document.getElementById('dMeta').innerHTML =
    '<span>IMP <span class="v">' + (node.importance * 100).toFixed(0) + '%</span></span>' +
    '<span>DECAY <span class="v">' + (decay * 100).toFixed(0) + '% ' + decayLabel + '</span></span>' +
    '<span>RECALLS <span class="v">' + node.accessCount + '</span></span>' +
    '<span>AGE <span class="v">' + age + '</span></span>' +
    (node.source ? '<span>SRC <span class="v">' + node.source + '</span></span>' : '');

  let tagsHtml = '';
  for (let i = 0; i < Math.min(node.tags.length, 8); i++) {
    tagsHtml += '<span class="detail-tag">' + node.tags[i] + '</span>';
  }
  document.getElementById('dTags').innerHTML = tagsHtml;

  document.getElementById('dEv').innerHTML = node.evidenceIds.length > 0
    ? 'EVIDENCE: <em>' + node.evidenceIds.length + ' linked memories</em>'
    : '';

  document.getElementById('detail').classList.add('vis');
}

function timeSince(dateStr) {
  if (!dateStr) return '?';
  const s = Math.floor((Date.now() - new Date(dateStr).getTime()) / 1000);
  if (s < 60) return s + 's';
  const m = Math.floor(s / 60);
  if (m < 60) return m + 'm';
  const h = Math.floor(m / 60);
  if (h < 24) return h + 'h';
  return Math.floor(h / 24) + 'd';
}

// ============================================
// HUD STATS
// ============================================
function updateStats() {
  document.getElementById('sNodes').textContent = memoryNodes.length;
  // Count evidence edges
  let edgeCount = 0;
  for (const n of memoryNodes) {
    for (const tid of n.evidenceIds) {
      if (nodeMap[tid]) edgeCount++;
    }
  }
  document.getElementById('sEdges').textContent = edgeCount;
  let td = 0, ti = 0;
  for (const n of memoryNodes) { td += n.decay; ti += n.importance; }
  document.getElementById('sDecay').textContent = memoryNodes.length ? ((td / memoryNodes.length) * 100).toFixed(0) + '%' : '--';
  document.getElementById('sImp').textContent = memoryNodes.length ? ((ti / memoryNodes.length) * 100).toFixed(0) + '%' : '--';
}

// ============================================
// ANIMATION LOOP
// ============================================
function animate() {
  requestAnimationFrame(animate);

  const dt = Math.min(clock.getDelta(), 0.05); // cap dt
  const time = clock.elapsedTime;

  // Update particle positions via curl noise flow
  updateParticles(time, dt);

  // Color particles near memory hotspots (every 3rd frame for perf)
  if (frameCount % 3 === 0) {
    colorParticlesNearMemories();
  }

  // Pulse waves
  schedulePulses(time);
  updatePulseWaves(dt);

  // Update GPU buffers
  particleGeometry.attributes.position.needsUpdate = true;
  particleGeometry.attributes.aColor.needsUpdate = true;
  particleGeometry.attributes.aSize.needsUpdate = true;
  particleGeometry.attributes.aAlpha.needsUpdate = true;

  // Raycasting (every 3rd frame for perf)
  if (frameCount % 3 === 0) {
    doRaycast();
  }

  // Smooth camera move to focused node
  if (targetFocus && targetCamPos) {
    controls.target.lerp(targetFocus, 0.06);
    camera.position.lerp(targetCamPos, 0.06);
  }

  // Pulse selected node highlight ring
  if (selectedNode && highlightRing.visible) {
    const t = performance.now() * 0.002;
    ringMat.opacity = 0.3 + 0.2 * Math.sin(t);
    highlightRing.position.copy(selectedNode.mesh.position);
    highlightRing.lookAt(camera.position);
  }

  // Gentle node breathing
  for (const n of memoryNodes) {
    if (!n.visible) continue;
    if (n === selectedNode) continue;
    const breathe = 1 + 0.05 * Math.sin(time * 1.5 + n.x * 0.1 + n.y * 0.07);
    n.mesh.scale.setScalar(breathe);
  }

  controls.update();
  composer.render();
  frameCount++;
}

// ============================================
// INIT
// ============================================
createParticleSystem();
fetchBrain();
animate();

// Refresh every 2 minutes
setInterval(fetchBrain, 120000);

</script>
</body>
</html>
