<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CLUDE — Documentation</title>
  <meta name="description" content="Cortex SDK documentation. Persistent memory for AI agents. Store, recall, dream cycles, association graphs.">
  <link rel="icon" type="image/svg+xml" href="/favicon.svg">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #f5f5f0;
      --bg-warm: #eeeee8;
      --surface: #fff;
      --text: #111;
      --text-muted: #666;
      --text-faint: #999;
      --border: rgba(0,0,0,0.08);
      --border-strong: rgba(0,0,0,0.15);
      --blue: #2244ff;
      --mono: 'JetBrains Mono', monospace;
      --sidebar-w: 240px;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }
    html { scroll-behavior: smooth; }

    body {
      font-family: var(--mono);
      background: var(--bg);
      color: var(--text);
      font-size: 13px;
      line-height: 1.7;
      -webkit-font-smoothing: antialiased;
    }

    ::selection { background: var(--text); color: var(--bg); }

    /* ── NAV ── */
    nav {
      position: fixed; top: 0; width: 100%; z-index: 100;
      background: rgba(245, 245, 240, 0.9);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border-bottom: 1px solid rgba(0,0,0,0.06);
    }
    .nav-inner {
      max-width: 1200px; margin: 0 auto; padding: 0 40px;
      height: 56px; display: flex; align-items: center;
    }
    .nav-logo {
      font-size: 13px; font-weight: 800; letter-spacing: 5px;
      color: var(--text); text-transform: uppercase; text-decoration: none;
    }
    .nav-links {
      display: flex; align-items: center; gap: 32px; margin-left: auto;
    }
    .nav-links a {
      color: var(--text-muted); font-size: 11px; letter-spacing: 2px;
      text-transform: uppercase; text-decoration: none; transition: color 0.3s;
    }
    .nav-links a:hover { color: var(--text); }
    .nav-links a.nav-active { color: var(--text); font-weight: 600; }

    /* ── MOBILE NAV ── */
    .nav-toggle {
      display: none; background: none;
      border: 1px solid var(--border);
      cursor: pointer; padding: 8px 7px; margin-left: auto;
    }
    .nav-toggle span {
      display: block; width: 16px; height: 1.5px;
      background: var(--text-muted); transition: all 0.3s;
    }
    .nav-toggle span + span { margin-top: 4px; }
    .nav-toggle.open span:nth-child(1) { transform: rotate(45deg) translate(3.5px, 3.5px); }
    .nav-toggle.open span:nth-child(2) { opacity: 0; }
    .nav-toggle.open span:nth-child(3) { transform: rotate(-45deg) translate(3.5px, -3.5px); }

    /* ── LAYOUT ── */
    .docs-layout {
      display: flex;
      max-width: 1200px;
      margin: 0 auto;
      padding-top: 56px;
      min-height: 100vh;
    }

    /* ── SIDEBAR ── */
    .sidebar {
      width: var(--sidebar-w);
      flex-shrink: 0;
      position: sticky;
      top: 56px;
      height: calc(100vh - 56px);
      overflow-y: auto;
      padding: 32px 24px 32px 40px;
      border-right: 1px solid var(--border);
    }
    .sidebar-label {
      font-size: 10px; letter-spacing: 3px; text-transform: uppercase;
      color: var(--text-faint); margin-bottom: 16px;
    }
    .sidebar-nav { list-style: none; }
    .sidebar-nav li { margin-bottom: 2px; }
    .sidebar-nav a {
      display: block;
      padding: 6px 12px;
      font-size: 12px;
      color: var(--text-muted);
      text-decoration: none;
      border-left: 2px solid transparent;
      transition: all 0.2s;
      letter-spacing: 0.3px;
    }
    .sidebar-nav a:hover {
      color: var(--text);
      border-left-color: var(--border-strong);
    }
    .sidebar-nav a.active {
      color: var(--text);
      font-weight: 600;
      border-left-color: var(--text);
    }
    .sidebar-version {
      margin-top: 24px;
      font-size: 10px;
      color: var(--text-faint);
      letter-spacing: 1px;
    }

    /* ── CONTENT ── */
    .docs-content {
      flex: 1;
      min-width: 0;
      padding: 48px 40px 80px 48px;
    }

    .doc-section {
      padding-bottom: 48px;
      margin-bottom: 48px;
      border-bottom: 1px solid var(--border);
    }
    .doc-section:last-child {
      border-bottom: none;
      margin-bottom: 0;
    }

    .doc-section h2 {
      font-size: 24px;
      font-weight: 700;
      letter-spacing: -0.5px;
      margin-bottom: 8px;
    }
    .doc-section h3 {
      font-size: 16px;
      font-weight: 700;
      margin-top: 32px;
      margin-bottom: 8px;
    }
    .doc-section h4 {
      font-size: 13px;
      font-weight: 700;
      margin-top: 24px;
      margin-bottom: 6px;
      color: var(--text-muted);
      letter-spacing: 1px;
      text-transform: uppercase;
    }

    .doc-section p {
      color: var(--text-muted);
      line-height: 1.8;
      margin-bottom: 16px;
      max-width: 640px;
    }
    .doc-section p code {
      background: var(--bg-warm);
      padding: 2px 6px;
      font-size: 12px;
      border: 1px solid var(--border);
    }

    .doc-lead {
      font-size: 14px;
      color: var(--text-muted);
      margin-bottom: 32px;
      max-width: 560px;
      line-height: 1.8;
    }

    /* ── CODE BLOCKS ── */
    .code {
      background: #1e1e1e;
      color: #d4d4d4;
      padding: 20px 24px;
      font-size: 12px;
      line-height: 1.8;
      overflow-x: auto;
      margin-bottom: 20px;
      border-radius: 4px;
      max-width: 680px;
    }
    .code .kw { color: #c586c0; }
    .code .str { color: #ce9178; }
    .code .type { color: #4ec9b0; }
    .code .fn { color: #dcdcaa; }
    .code .cmt { color: #6a9955; }
    .code .num { color: #b5cea8; }
    .code .prompt { color: #666; }
    .code .cmd { color: #d4d4d4; }
    .code .flag { color: #9cdcfe; }

    /* ── INLINE CODE ── */
    code {
      font-family: var(--mono);
    }

    /* ── TABLES ── */
    .doc-table {
      width: 100%;
      max-width: 680px;
      border-collapse: collapse;
      margin-bottom: 20px;
      font-size: 12px;
    }
    .doc-table th {
      text-align: left;
      font-size: 10px;
      letter-spacing: 2px;
      text-transform: uppercase;
      color: var(--text-faint);
      padding: 10px 16px;
      border-bottom: 2px solid var(--border-strong);
      font-weight: 600;
    }
    .doc-table td {
      padding: 10px 16px;
      border-bottom: 1px solid var(--border);
      vertical-align: top;
    }
    .doc-table td code {
      background: var(--bg-warm);
      padding: 1px 5px;
      font-size: 11px;
      border: 1px solid var(--border);
    }
    .doc-table tr:last-child td { border-bottom: none; }
    .doc-table .required {
      color: var(--text);
      font-weight: 600;
    }
    .doc-table .optional {
      color: var(--text-faint);
    }

    /* ── CALLOUTS ── */
    .callout {
      padding: 16px 20px;
      border-left: 3px solid var(--text);
      background: var(--bg-warm);
      margin-bottom: 20px;
      max-width: 680px;
      font-size: 12px;
      color: var(--text-muted);
      line-height: 1.8;
    }
    .callout-label {
      font-size: 10px;
      letter-spacing: 2px;
      text-transform: uppercase;
      font-weight: 700;
      color: var(--text);
      margin-bottom: 4px;
    }

    /* ── PARAM LIST ── */
    .param-list { margin-bottom: 20px; }
    .param {
      padding: 8px 0;
      border-bottom: 1px solid var(--border);
      display: flex;
      gap: 12px;
      align-items: baseline;
      max-width: 680px;
    }
    .param:last-child { border-bottom: none; }
    .param-name {
      font-weight: 600;
      font-size: 12px;
      min-width: 140px;
      flex-shrink: 0;
    }
    .param-name code {
      background: var(--bg-warm);
      padding: 1px 5px;
      border: 1px solid var(--border);
      font-size: 11px;
    }
    .param-desc {
      font-size: 12px;
      color: var(--text-muted);
    }
    .param-type {
      font-size: 11px;
      color: var(--text-faint);
    }

    /* ── FOOTER ── */
    .footer {
      padding: 40px;
      border-top: 1px solid var(--border);
      text-align: center;
      font-size: 11px;
      color: var(--text-faint);
      letter-spacing: 3px;
      text-transform: uppercase;
    }

    /* ── MOBILE SIDEBAR TOGGLE ── */
    .sidebar-toggle {
      display: none;
      position: fixed;
      bottom: 24px;
      right: 24px;
      z-index: 90;
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: var(--text);
      color: var(--bg);
      border: none;
      cursor: pointer;
      font-family: var(--mono);
      font-size: 18px;
      font-weight: 300;
      box-shadow: 0 4px 16px rgba(0,0,0,0.2);
    }

    /* ── RESPONSIVE ── */
    @media (max-width: 768px) {
      .nav-toggle { display: flex; flex-direction: column; }
      .nav-links {
        display: none; position: absolute; top: 56px; left: 0; right: 0;
        background: rgba(245, 245, 240, 0.97);
        backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
        border-bottom: 1px solid var(--border);
        flex-direction: column; padding: 1.2rem 2rem; gap: 1.2rem;
      }
      .nav-links.open { display: flex; }
      .nav-inner { padding: 0 1rem; }

      .sidebar {
        position: fixed;
        top: 56px;
        left: 0;
        width: 280px;
        height: calc(100vh - 56px);
        background: var(--bg);
        z-index: 80;
        transform: translateX(-100%);
        transition: transform 0.3s ease;
        border-right: 1px solid var(--border);
        padding: 24px;
      }
      .sidebar.open {
        transform: translateX(0);
      }
      .sidebar-overlay {
        display: none;
        position: fixed;
        inset: 0;
        top: 56px;
        background: rgba(0,0,0,0.2);
        z-index: 79;
      }
      .sidebar-overlay.open { display: block; }
      .sidebar-toggle { display: flex; align-items: center; justify-content: center; }
      .docs-content { padding: 32px 24px 80px; }
      .code { font-size: 11px; padding: 16px; }
    }

    @media (min-width: 769px) {
      .sidebar-overlay { display: none !important; }
    }
  </style>
</head>
<body>

<nav>
  <div class="nav-inner">
    <a href="/" class="nav-logo">Clude</a>
    <button class="nav-toggle" id="navToggle" aria-label="Menu"><span></span><span></span><span></span></button>
    <div class="nav-links">
      <a href="/docs.html" class="nav-active">Docs</a>
      <a href="/demo.html">Demo</a>
      <a href="/brain.html">Brain</a>
      <a href="https://x.com/Cludebot" target="_blank">X</a>
    </div>
  </div>
</nav>

<div class="sidebar-overlay" id="sidebarOverlay"></div>

<div class="docs-layout">
  <aside class="sidebar" id="sidebar">
    <div class="sidebar-label">Documentation</div>
    <ul class="sidebar-nav" id="sidebarNav">
      <li><a href="#quick-start" class="active">Quick Start</a></li>
      <li><a href="#configuration">Configuration</a></li>
      <li><a href="#storing">Storing Memories</a></li>
      <li><a href="#recalling">Recalling Memories</a></li>
      <li><a href="#dream-cycles">Dream Cycles</a></li>
      <li><a href="#association-graph">Association Graph</a></li>
      <li><a href="#utilities">Utilities</a></li>
      <li><a href="#events">Events</a></li>
      <li><a href="#database">Database Schema</a></li>
      <li><a href="#degradation">Graceful Degradation</a></li>
    </ul>
    <div class="sidebar-version">v2.2.0</div>
  </aside>

  <main class="docs-content">

    <!-- ═══════ QUICK START ═══════ -->
    <div class="doc-section" id="quick-start">
      <h2>Quick Start</h2>
      <p class="doc-lead">Install the SDK, run the interactive wizard, and give your AI agent persistent memory in under a minute.</p>

      <h3>Install</h3>
      <div class="code">
        <span class="prompt">$</span> <span class="cmd">npm install clude-bot</span>
      </div>

      <h3>Setup</h3>
      <p>The init wizard walks you through configuring Supabase, Anthropic, Solana, and embeddings. All steps are skippable.</p>
      <div class="code">
        <span class="prompt">$</span> <span class="cmd">npx clude-bot init</span>
      </div>
      <p>This generates a <code>.env</code> file and shows a ready-to-use code snippet.</p>

      <h3>Database</h3>
      <p>Clude uses Supabase with pgvector. Run the schema against your Supabase project:</p>
      <div class="code">
        <span class="prompt">$</span> <span class="cmd">psql</span> <span class="flag">$DATABASE_URL</span> <span class="cmd">-f node_modules/clude-bot/supabase-schema.sql</span>
      </div>

      <h3>Usage</h3>
      <div class="code">
<span class="kw">import</span> { Cortex } <span class="kw">from</span> <span class="str">'clude-bot'</span>;

<span class="kw">const</span> brain = <span class="kw">new</span> <span class="type">Cortex</span>({
  supabase: {
    url: process.env.<span class="flag">SUPABASE_URL</span>,
    serviceKey: process.env.<span class="flag">SUPABASE_SERVICE_KEY</span>,
  },
});

<span class="kw">await</span> brain.<span class="fn">init</span>();

<span class="cmt">// Store a memory</span>
<span class="kw">await</span> brain.<span class="fn">store</span>({
  type: <span class="str">'episodic'</span>,
  content: <span class="str">'User asked about deployment options'</span>,
  summary: <span class="str">'Deployment inquiry'</span>,
  source: <span class="str">'my-agent'</span>,
});

<span class="cmt">// Recall with hybrid search</span>
<span class="kw">const</span> memories = <span class="kw">await</span> brain.<span class="fn">recall</span>({
  query: <span class="str">'what did the user ask about'</span>,
});

console.<span class="fn">log</span>(memories);
      </div>

      <div class="callout">
        <div class="callout-label">Note</div>
        Only <code>supabase</code> config is required. Everything else (Anthropic, embeddings, Solana) is optional and degrades gracefully.
      </div>
    </div>

    <!-- ═══════ CONFIGURATION ═══════ -->
    <div class="doc-section" id="configuration">
      <h2>Configuration</h2>
      <p class="doc-lead">The <code>Cortex</code> constructor accepts a <code>CortexConfig</code> object. Only Supabase credentials are required.</p>

      <div class="code">
<span class="kw">const</span> brain = <span class="kw">new</span> <span class="type">Cortex</span>({
  <span class="cmt">// Required</span>
  supabase: {
    url: <span class="str">'https://xxx.supabase.co'</span>,
    serviceKey: <span class="str">'eyJ...'</span>,
  },

  <span class="cmt">// Optional — enables dream cycles + LLM importance scoring</span>
  anthropic: {
    apiKey: <span class="str">'sk-ant-...'</span>,
    model: <span class="str">'claude-sonnet-4-5-20250929'</span>,  <span class="cmt">// default: claude-sonnet-4-5-20250929</span>
  },

  <span class="cmt">// Optional — enables vector similarity search</span>
  embedding: {
    provider: <span class="str">'voyage'</span>,  <span class="cmt">// 'voyage' | 'openai'</span>
    apiKey: <span class="str">'pa-...'</span>,
    model: <span class="str">'voyage-3'</span>,
    dimensions: <span class="num">1024</span>,
  },

  <span class="cmt">// Optional — enables on-chain memory commits</span>
  solana: {
    rpcUrl: <span class="str">'https://api.mainnet-beta.solana.com'</span>,
    botWalletPrivateKey: <span class="str">'base58...'</span>,
  },
});
      </div>

      <h3>supabase (required)</h3>
      <table class="doc-table">
        <tr><th>Field</th><th>Type</th><th>Description</th></tr>
        <tr><td><code>url</code></td><td class="required">string</td><td>Supabase project URL</td></tr>
        <tr><td><code>serviceKey</code></td><td class="required">string</td><td>Supabase service role key</td></tr>
      </table>

      <h3>anthropic (optional)</h3>
      <table class="doc-table">
        <tr><th>Field</th><th>Type</th><th>Description</th></tr>
        <tr><td><code>apiKey</code></td><td class="required">string</td><td>Anthropic API key</td></tr>
        <tr><td><code>model</code></td><td class="optional">string</td><td>Model ID. Default: <code>claude-sonnet-4-5-20250929</code></td></tr>
      </table>

      <h3>embedding (optional)</h3>
      <table class="doc-table">
        <tr><th>Field</th><th>Type</th><th>Description</th></tr>
        <tr><td><code>provider</code></td><td class="required">'voyage' | 'openai'</td><td>Embedding provider</td></tr>
        <tr><td><code>apiKey</code></td><td class="required">string</td><td>Provider API key</td></tr>
        <tr><td><code>model</code></td><td class="optional">string</td><td>Model name (e.g. <code>voyage-3</code>)</td></tr>
        <tr><td><code>dimensions</code></td><td class="optional">number</td><td>Vector dimensions. Default: <code>1024</code></td></tr>
      </table>

      <h3>solana (optional)</h3>
      <table class="doc-table">
        <tr><th>Field</th><th>Type</th><th>Description</th></tr>
        <tr><td><code>rpcUrl</code></td><td class="optional">string</td><td>Solana RPC endpoint. Default: mainnet</td></tr>
        <tr><td><code>botWalletPrivateKey</code></td><td class="optional">string</td><td>Base58 private key for memo transactions</td></tr>
      </table>
    </div>

    <!-- ═══════ STORING MEMORIES ═══════ -->
    <div class="doc-section" id="storing">
      <h2>Storing Memories</h2>
      <p class="doc-lead">Store memories with automatic importance scoring, concept inference, and optional on-chain commitment.</p>

      <div class="code">
<span class="kw">const</span> id = <span class="kw">await</span> brain.<span class="fn">store</span>({
  type: <span class="str">'semantic'</span>,
  content: <span class="str">'Users who hold &gt;1M tokens tend to ask about governance'</span>,
  summary: <span class="str">'Whale holder behavior pattern'</span>,
  source: <span class="str">'analysis-agent'</span>,
  tags: [<span class="str">'whale'</span>, <span class="str">'governance'</span>],
  importance: <span class="num">0.8</span>,
});

console.<span class="fn">log</span>(id); <span class="cmt">// 42 (memory ID) or null on failure</span>
      </div>

      <h3>StoreMemoryOptions</h3>
      <table class="doc-table">
        <tr><th>Field</th><th>Type</th><th>Description</th></tr>
        <tr><td><code>type</code></td><td class="required">MemoryType</td><td><code>'episodic'</code> | <code>'semantic'</code> | <code>'procedural'</code> | <code>'self_model'</code></td></tr>
        <tr><td><code>content</code></td><td class="required">string</td><td>Full memory content (max 5000 chars)</td></tr>
        <tr><td><code>summary</code></td><td class="required">string</td><td>Short summary for recall matching (max 500 chars)</td></tr>
        <tr><td><code>source</code></td><td class="required">string</td><td>Identifier for the agent storing the memory</td></tr>
        <tr><td><code>tags</code></td><td class="optional">string[]</td><td>Tags for filtering (max 20)</td></tr>
        <tr><td><code>concepts</code></td><td class="optional">string[]</td><td>Structured concepts (auto-inferred if omitted)</td></tr>
        <tr><td><code>importance</code></td><td class="optional">number</td><td>0-1 scale. LLM-scored if omitted (requires anthropic config)</td></tr>
        <tr><td><code>emotionalValence</code></td><td class="optional">number</td><td>-1 (negative) to 1 (positive). Default: 0</td></tr>
        <tr><td><code>sourceId</code></td><td class="optional">string</td><td>External ID (e.g. tweet ID, message ID)</td></tr>
        <tr><td><code>relatedUser</code></td><td class="optional">string</td><td>Associated user identifier</td></tr>
        <tr><td><code>relatedWallet</code></td><td class="optional">string</td><td>Associated wallet address</td></tr>
        <tr><td><code>metadata</code></td><td class="optional">Record&lt;string, unknown&gt;</td><td>Arbitrary metadata</td></tr>
        <tr><td><code>evidenceIds</code></td><td class="optional">number[]</td><td>IDs of supporting memories</td></tr>
      </table>

      <h3>Memory Types</h3>
      <p>Each type has a different decay rate, mirroring biological memory:</p>
      <table class="doc-table">
        <tr><th>Type</th><th>Decay / Day</th><th>Purpose</th></tr>
        <tr><td><code>episodic</code></td><td>7%</td><td>Raw interactions. Who said what, when.</td></tr>
        <tr><td><code>semantic</code></td><td>2%</td><td>Distilled knowledge. Patterns and insights.</td></tr>
        <tr><td><code>procedural</code></td><td>3%</td><td>Learned behavior. What works, what doesn't.</td></tr>
        <tr><td><code>self_model</code></td><td>1%</td><td>Evolving self-understanding. Nearly permanent.</td></tr>
      </table>

      <h3>Concept Ontology</h3>
      <p>Memories are automatically tagged with structured concepts from a controlled vocabulary of 12 labels:</p>
      <p><code>market_event</code>, <code>holder_behavior</code>, <code>self_insight</code>, <code>social_interaction</code>, <code>community_pattern</code>, <code>token_economics</code>, <code>sentiment_shift</code>, <code>recurring_user</code>, <code>whale_activity</code>, <code>price_action</code>, <code>engagement_pattern</code>, <code>identity_evolution</code></p>
    </div>

    <!-- ═══════ RECALLING MEMORIES ═══════ -->
    <div class="doc-section" id="recalling">
      <h2>Recalling Memories</h2>
      <p class="doc-lead">Hybrid retrieval combining vector similarity, keyword matching, tag scoring, and graph traversal. Ranked by the Generative Agents formula.</p>

      <h3>recall(opts?)</h3>
      <p>Returns full <code>Memory</code> objects ranked by composite score.</p>
      <div class="code">
<span class="kw">const</span> memories = <span class="kw">await</span> brain.<span class="fn">recall</span>({
  query: <span class="str">'what does the user prefer'</span>,
  tags: [<span class="str">'preferences'</span>],
  memoryTypes: [<span class="str">'episodic'</span>, <span class="str">'semantic'</span>],
  limit: <span class="num">10</span>,
  minImportance: <span class="num">0.3</span>,
});
      </div>

      <h3>RecallOptions</h3>
      <table class="doc-table">
        <tr><th>Field</th><th>Type</th><th>Description</th></tr>
        <tr><td><code>query</code></td><td class="optional">string</td><td>Natural language search query</td></tr>
        <tr><td><code>tags</code></td><td class="optional">string[]</td><td>Filter by tags</td></tr>
        <tr><td><code>relatedUser</code></td><td class="optional">string</td><td>Filter by associated user</td></tr>
        <tr><td><code>memoryTypes</code></td><td class="optional">MemoryType[]</td><td>Filter by memory type</td></tr>
        <tr><td><code>limit</code></td><td class="optional">number</td><td>Max results to return</td></tr>
        <tr><td><code>minImportance</code></td><td class="optional">number</td><td>Minimum importance threshold (0-1)</td></tr>
        <tr><td><code>minDecay</code></td><td class="optional">number</td><td>Minimum decay factor threshold</td></tr>
        <tr><td><code>trackAccess</code></td><td class="optional">boolean</td><td>Update access count and timestamp. Default: true</td></tr>
      </table>

      <h3>Retrieval Scoring</h3>
      <p>Each memory is scored with the additive formula from Park et al. 2023:</p>
      <div class="code">
score = (<span class="num">0.5</span> * recency) + (<span class="num">3.0</span> * relevance) + (<span class="num">2.0</span> * importance) + (<span class="num">3.0</span> * vector_similarity) + (<span class="num">1.5</span> * graph_boost)
      </div>
      <p>All scores are gated by each memory's <code>decay_factor</code>.</p>

      <h3>recallSummaries(opts?)</h3>
      <p>Returns lightweight <code>MemorySummary</code> objects (no content field). Use for progressive disclosure — list summaries first, then hydrate the ones you need.</p>
      <div class="code">
<span class="kw">const</span> summaries = <span class="kw">await</span> brain.<span class="fn">recallSummaries</span>({
  query: <span class="str">'recent events'</span>,
});

<span class="cmt">// Pick the most relevant ones and hydrate</span>
<span class="kw">const</span> ids = summaries.<span class="fn">slice</span>(<span class="num">0</span>, <span class="num">3</span>).<span class="fn">map</span>(s => s.id);
<span class="kw">const</span> full = <span class="kw">await</span> brain.<span class="fn">hydrate</span>(ids);
      </div>

      <h3>hydrate(ids)</h3>
      <p>Fetch full <code>Memory</code> objects by ID. Useful after <code>recallSummaries()</code> to get content for specific memories.</p>
      <div class="code">
<span class="kw">const</span> memories = <span class="kw">await</span> brain.<span class="fn">hydrate</span>([<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>]);
      </div>
    </div>

    <!-- ═══════ DREAM CYCLES ═══════ -->
    <div class="doc-section" id="dream-cycles">
      <h2>Dream Cycles</h2>
      <p class="doc-lead">A three-phase introspection cycle inspired by biological memory consolidation. Requires <code>anthropic</code> config.</p>

      <h3>dream(opts?)</h3>
      <p>Run one full dream cycle: consolidation, reflection, emergence.</p>
      <div class="code">
<span class="cmt">// Basic dream</span>
<span class="kw">await</span> brain.<span class="fn">dream</span>();

<span class="cmt">// With emergence callback</span>
<span class="kw">await</span> brain.<span class="fn">dream</span>({
  onEmergence: <span class="kw">async</span> (text) => {
    console.<span class="fn">log</span>(<span class="str">'Emergence:'</span>, text);
    <span class="cmt">// Post to your channel, save to file, etc.</span>
  },
});
      </div>

      <h3>Dream Phases</h3>
      <table class="doc-table">
        <tr><th>Phase</th><th>What Happens</th></tr>
        <tr><td><strong>I. Consolidation</strong></td><td>Generates focal questions from recent memories. Each question retrieves evidence and produces new semantic insights with citation chains.</td></tr>
        <tr><td><strong>II. Reflection</strong></td><td>Self-model review against accumulated knowledge. Identity evolves based on experience.</td></tr>
        <tr><td><strong>III. Emergence</strong></td><td>Examines its own existence. Output sent to <code>onEmergence</code> callback if provided.</td></tr>
      </table>

      <h3>startDreamSchedule() / stopDreamSchedule()</h3>
      <p>Run dream cycles on a 6-hour cron schedule with daily memory decay.</p>
      <div class="code">
brain.<span class="fn">startDreamSchedule</span>();

<span class="cmt">// Later...</span>
brain.<span class="fn">stopDreamSchedule</span>();
      </div>

      <div class="callout">
        <div class="callout-label">Requires</div>
        Dream cycles require <code>anthropic</code> config. Calling <code>dream()</code> without it throws an error.
      </div>
    </div>

    <!-- ═══════ ASSOCIATION GRAPH ═══════ -->
    <div class="doc-section" id="association-graph">
      <h2>Association Graph</h2>
      <p class="doc-lead">Typed, weighted links between memories. Connections strengthen through co-retrieval (Hebbian reinforcement).</p>

      <h3>link(sourceId, targetId, type, strength?)</h3>
      <div class="code">
<span class="kw">await</span> brain.<span class="fn">link</span>(<span class="num">42</span>, <span class="num">87</span>, <span class="str">'supports'</span>, <span class="num">0.8</span>);
      </div>

      <h3>Link Types</h3>
      <table class="doc-table">
        <tr><th>Type</th><th>Meaning</th></tr>
        <tr><td><code>supports</code></td><td>Source provides evidence for target</td></tr>
        <tr><td><code>contradicts</code></td><td>Source conflicts with target</td></tr>
        <tr><td><code>elaborates</code></td><td>Source adds detail to target</td></tr>
        <tr><td><code>causes</code></td><td>Source led to or caused target</td></tr>
        <tr><td><code>follows</code></td><td>Source happened after target (temporal)</td></tr>
        <tr><td><code>relates</code></td><td>General association</td></tr>
      </table>

      <h3>Hebbian Reinforcement</h3>
      <p>When two linked memories are recalled together, their link strength increases by <code>0.05</code>. The graph evolves through use, not programming.</p>
      <p>During recall, linked memories receive a graph boost weighted at <code>1.5x</code> in the scoring formula.</p>
    </div>

    <!-- ═══════ UTILITIES ═══════ -->
    <div class="doc-section" id="utilities">
      <h2>Utilities</h2>

      <h3>decay()</h3>
      <p>Apply type-specific memory decay. Returns the number of memories decayed. Typically called on a daily schedule (handled automatically by <code>startDreamSchedule</code>).</p>
      <div class="code">
<span class="kw">const</span> count = <span class="kw">await</span> brain.<span class="fn">decay</span>();
console.<span class="fn">log</span>(<span class="str">`Decayed ${count} memories`</span>);
      </div>

      <h3>stats()</h3>
      <p>Returns aggregate statistics about the memory system.</p>
      <div class="code">
<span class="kw">const</span> stats = <span class="kw">await</span> brain.<span class="fn">stats</span>();
<span class="cmt">// {
//   total: 1500,
//   byType: { episodic: 900, semantic: 400, procedural: 120, self_model: 80 },
//   avgImportance: 0.65,
//   avgDecay: 0.88,
//   topTags: [{ tag: 'market', count: 200 }, ...],
//   topConcepts: [{ concept: 'social_interaction', count: 150 }, ...],
//   embeddedCount: 1200,
//   ...
// }</span>
      </div>

      <h3>recent(hours, types?, limit?)</h3>
      <p>Get memories from the last N hours, optionally filtered by type.</p>
      <div class="code">
<span class="kw">const</span> last24h = <span class="kw">await</span> brain.<span class="fn">recent</span>(<span class="num">24</span>);
<span class="kw">const</span> recentSemantic = <span class="kw">await</span> brain.<span class="fn">recent</span>(<span class="num">6</span>, [<span class="str">'semantic'</span>], <span class="num">5</span>);
      </div>

      <h3>selfModel()</h3>
      <p>Get current self-model memories. These represent the agent's evolving self-understanding.</p>
      <div class="code">
<span class="kw">const</span> identity = <span class="kw">await</span> brain.<span class="fn">selfModel</span>();
      </div>

      <h3>scoreImportance(description)</h3>
      <p>Score a text's importance using the LLM (0-1). Falls back to rule-based scoring if no anthropic config.</p>
      <div class="code">
<span class="kw">const</span> score = <span class="kw">await</span> brain.<span class="fn">scoreImportance</span>(<span class="str">'User reported critical bug in auth flow'</span>);
<span class="cmt">// 0.85</span>
      </div>

      <h3>formatContext(memories)</h3>
      <p>Format an array of memories into a context string suitable for LLM prompts.</p>
      <div class="code">
<span class="kw">const</span> memories = <span class="kw">await</span> brain.<span class="fn">recall</span>({ query: <span class="str">'user context'</span> });
<span class="kw">const</span> context = brain.<span class="fn">formatContext</span>(memories);
<span class="cmt">// Use `context` in your LLM system prompt</span>
      </div>

      <h3>inferConcepts(summary, source, tags)</h3>
      <p>Infer structured concepts from memory metadata. Returns an array of concept labels from the controlled vocabulary.</p>
      <div class="code">
<span class="kw">const</span> concepts = brain.<span class="fn">inferConcepts</span>(
  <span class="str">'Large holder sold 500k tokens'</span>,
  <span class="str">'market-watcher'</span>,
  [<span class="str">'whale'</span>, <span class="str">'sell'</span>],
);
<span class="cmt">// ['whale_activity', 'holder_behavior', 'token_economics']</span>
      </div>

      <h3>destroy()</h3>
      <p>Clean up resources, stop dream schedules, and remove event listeners.</p>
      <div class="code">
brain.<span class="fn">destroy</span>();
      </div>
    </div>

    <!-- ═══════ EVENTS ═══════ -->
    <div class="doc-section" id="events">
      <h2>Events</h2>
      <p class="doc-lead">Listen for memory system events via the internal event bus.</p>

      <h3>on('memory:stored', handler)</h3>
      <p>Fired every time a memory is stored. Receives importance score and memory type.</p>
      <div class="code">
brain.<span class="fn">on</span>(<span class="str">'memory:stored'</span>, (payload) => {
  console.<span class="fn">log</span>(payload.importance);  <span class="cmt">// 0.75</span>
  console.<span class="fn">log</span>(payload.memoryType);   <span class="cmt">// 'episodic'</span>
});
      </div>

      <p>Episodic memories automatically accumulate importance toward triggering dream cycles.</p>
    </div>

    <!-- ═══════ DATABASE SCHEMA ═══════ -->
    <div class="doc-section" id="database">
      <h2>Database Schema</h2>
      <p class="doc-lead">Clude uses Supabase PostgreSQL with the pgvector extension for vector similarity search.</p>

      <h3>Setup</h3>
      <p>The schema file is included in the npm package:</p>
      <div class="code">
<span class="prompt">$</span> <span class="cmd">psql</span> <span class="flag">$DATABASE_URL</span> <span class="cmd">-f node_modules/clude-bot/supabase-schema.sql</span>
      </div>
      <p>Or import it directly:</p>
      <div class="code">
<span class="kw">import</span> schema <span class="kw">from</span> <span class="str">'clude-bot/schema'</span>;
<span class="cmt">// Path to supabase-schema.sql</span>
      </div>

      <h3>Tables</h3>
      <table class="doc-table">
        <tr><th>Table</th><th>Purpose</th></tr>
        <tr><td><code>memories</code></td><td>Core memory store with pgvector embedding column</td></tr>
        <tr><td><code>memory_links</code></td><td>Association graph edges (typed, weighted)</td></tr>
        <tr><td><code>memory_fragments</code></td><td>Per-fragment embeddings for granular vector search</td></tr>
        <tr><td><code>dream_sessions</code></td><td>Dream cycle history and outputs</td></tr>
        <tr><td><code>linked_wallets</code></td><td>X handle to Solana wallet mappings</td></tr>
      </table>

      <h3>pgvector</h3>
      <p>The schema creates HNSW indexes for fast vector search. Make sure the <code>vector</code> extension is enabled in your Supabase project (it is by default).</p>

      <div class="callout">
        <div class="callout-label">Note</div>
        HNSW indexes perform best after data is loaded. If you're starting fresh, the system gracefully falls back to keyword-only retrieval until enough embeddings are present.
      </div>
    </div>

    <!-- ═══════ GRACEFUL DEGRADATION ═══════ -->
    <div class="doc-section" id="degradation">
      <h2>Graceful Degradation</h2>
      <p class="doc-lead">The SDK works with minimal config and progressively unlocks features as you add more.</p>

      <table class="doc-table">
        <tr><th>Feature</th><th>Config Needed</th><th>Without It</th></tr>
        <tr><td>Store / Recall</td><td><code>supabase</code></td><td>Constructor throws</td></tr>
        <tr><td>Vector search</td><td><code>embedding</code></td><td>Keyword + tag scoring only</td></tr>
        <tr><td>LLM importance</td><td><code>anthropic</code></td><td>Rule-based <code>calculateImportance()</code></td></tr>
        <tr><td>Dream cycles</td><td><code>anthropic</code></td><td><code>dream()</code> throws clear error</td></tr>
        <tr><td>On-chain commits</td><td><code>solana</code></td><td>Silently skipped</td></tr>
        <tr><td>Emergence output</td><td><code>onEmergence</code></td><td>Output discarded (SDK never tweets)</td></tr>
      </table>

      <div class="callout">
        <div class="callout-label">Minimal setup</div>
        With just <code>supabase</code> config, you get full store/recall with keyword matching, tag scoring, type-specific decay, and the association graph. Add embedding and anthropic configs later as needed.
      </div>
    </div>

  </main>
</div>

<div class="footer">CLUDE &middot; clude.io</div>

<button class="sidebar-toggle" id="sidebarToggle" aria-label="Toggle navigation">&equiv;</button>

<script>
(function() {
  'use strict';

  // ── NAV TOGGLE ──
  var navToggle = document.getElementById('navToggle');
  if (navToggle) {
    navToggle.addEventListener('click', function() {
      this.classList.toggle('open');
      document.querySelector('.nav-links').classList.toggle('open');
    });
  }

  // ── SIDEBAR TOGGLE (MOBILE) ──
  var sidebarToggle = document.getElementById('sidebarToggle');
  var sidebar = document.getElementById('sidebar');
  var overlay = document.getElementById('sidebarOverlay');

  function closeSidebar() {
    sidebar.classList.remove('open');
    overlay.classList.remove('open');
  }

  if (sidebarToggle) {
    sidebarToggle.addEventListener('click', function() {
      sidebar.classList.toggle('open');
      overlay.classList.toggle('open');
    });
  }

  if (overlay) {
    overlay.addEventListener('click', closeSidebar);
  }

  // Close sidebar on link click (mobile)
  document.querySelectorAll('.sidebar-nav a').forEach(function(link) {
    link.addEventListener('click', function() {
      if (window.innerWidth <= 768) {
        closeSidebar();
      }
    });
  });

  // ── ACTIVE SIDEBAR LINK ON SCROLL ──
  var sections = document.querySelectorAll('.doc-section');
  var navLinks = document.querySelectorAll('.sidebar-nav a');

  var observer = new IntersectionObserver(function(entries) {
    entries.forEach(function(entry) {
      if (entry.isIntersecting) {
        var id = entry.target.id;
        navLinks.forEach(function(link) {
          link.classList.toggle('active', link.getAttribute('href') === '#' + id);
        });
      }
    });
  }, {
    rootMargin: '-80px 0px -60% 0px',
    threshold: 0
  });

  sections.forEach(function(section) {
    observer.observe(section);
  });
})();
</script>
</body>
</html>
